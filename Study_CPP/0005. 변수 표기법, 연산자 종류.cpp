/*

2019.03.18.01 월

복습 - 크기와 저장하고 있는 데이터에 따른 분류, 리터럴 상수의 default 값

################################################################################

######
표기법
######

- 변수 이름을 설정할 때 해당 소속의 규칙에 맞도록 설정하는 방법
- 가독성을 위해 개발자들끼리 규칙을 정해 놓은 것

- 프로젝트를 진행할 때 여러 사람들과 같이 작업을 진행하게 되는데,
 이때 공동 작업 및 타인 코드 참고 시 규모가 큰 프로젝트일 경우 파악이 어렵다 !!!


case 1. 헝가리안 표기법
- 없어지고 있는 추세이나 쓰는 사람 있긴 함.
- 변수명 앞에 자료형을 나타내는 문자를 삽입한다.
- 수식어구가 길어질 수도 있고, 마우스를 가져다 놓으면 자료형 보여줌 ㅋㅋㅋㅋ

ex.
char		chTest = 'A';
bool		bTest = true;
short		nTest = 10;

int			iTest = 20;
long		lTest = 30;
float		fTest = 3.14f;

double		dTest = 3.1415;
long double ldTest = 3.141592;
long long	llTest = 40;


case 2. 카멜 표기법
- 단어와 단어 사이를 대문자로 구분하는 방법
- 변수명이 소문자로 시작하고, 복합어일 경우 중간에 새로운 단어는 대문자로 시작한다.

ex. int playerHp;


case 3. 파스칼 표기법
- 카멜 표기법과 비슷하지만, 변수명이 대문자로 시작하고, 복합어일 경우 중간에 새로운 단어는 대문자로 시작한다.

ex. int PlayerHp;


case 4. 언더바(_) 표기법
- 단어와 단어 사이에 언더바를 사용한다.
- 주로 함수의 매개변수(인자) 앞에 사용한다.

ex. int player_hp;

################################################################################

######
연산자
######

- 연산을 수행하고서 연산 결과를 반환하는 것

종류
- 산술 연산자
- sizeof연산자
- 대입 연산자
- 관계 연산자
- 비트단위 연산자 등...

- 단항 연산자(피연산자 1개)
- 이항 연산자(피연산자 2개)
- 삼항 연산자(피연산자 3개)

////////////////////////////////////////////////////////////////////////////////////////
case 1. 산술 연산자 - (이항 연산자)

+(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(나머지) 그래도, 음수 나머지 한번 예제 만들어보셈.


X % Y 나머지 연산이라고 하면, 부호에 상관없이 계산을 한 뒤
X의 부호와 같은 부호를 써주면 된다 !!!!

////////////////////////////////////////////////////////////////////////////////////////
case 2. sizeof 연산자 - (단항 연산자)
- 확인하고자 하는 변수 및 자료형의 크기를 byte 단위로 반환해주는 연산자.

ex. int playerHP;
- sizeof(int);
- sizeof(playerHP);

////////////////////////////////////////////////////////////////////////////////////////
case 3. 대입 연산자 - (이항 연산자)
- (오른쪽에서 왼쪽으로) 대입이 이루어진다. // 연산 방향이 중요함.

- 대입 연산자의 피연산자들은 같은 자료형이어야 한다.

////////////////////////////////////////////////////////////////////////////////////////
case 4. 관계(비교) 연산자 - (이항 연산자)
- <, >, <=, >=, ==, !=

- 두 항의 대소 관계를 비교하여 참(1) or 거짓(0)을 반환하는 연산자

- () 소괄호를 통해 우선순위를 설정하여 체크할 것.

////////////////////////////////////////////////////////////////////////////////////////
case 5. 논리 연산자 - (이항 연산자, !(NOT)만 단항 연산자)
- &&(AND), ||(OR), !(NOT) - 비트 연산자에서 NOT은 (~) 주의할 것.

- 피연산자로 '조건'을 가진다.
- 두 조건을 만족하는 경우 or 하나만 만족하는 경우 등을 판별할 때 쓰임.
- 참(1) or 거짓(0)을 반환한다.

 &&(AND) - 두 조건이 참(1)이어야 결과가 참(1), 그 외에는 거짓(0).
true && true = true
true && false = false
false && true = false
false && false = false

	 ########################
but, Short Circuit Evaluation 때문에 첫 조건이 거짓이면, 뒷 조건의 문장은 실행도 안 함 !!!
	 ########################

 ||(OR) - 한 조건이라도 참(1)이면 결과가 참(1), 모두다 거짓(0)이어야 결과가 거짓(0).
true || true = true
true || false = true
fasle || true = true
fasle || false = false

	 ########################
but, Short Circuit Evaluation 때문에 첫 조건이 참이면, 뒷 조건의 문장은 실행도 안 함 !!!
	 ########################

 !(NOT) - 참(1)은 거짓(0)으로 거짓(0)은 참(1)으로 바꾼다. = 논리 부정을 의미함.

 !(true) = false
 !(false) = true

////////////////////////////////////////////////////////////////////////////////////////
case 6. 비트 단위 논리 연산자 - (이항 연산자, ~(NOT)만 단항 연산자)
- &(AND), |(OR), ~(NOT), ^(XOR)
- 두 개의 피연산자에 대하여 비트열을 비교한다.

자리수에 맞춰 비교함.
10 = 1010
14 = 1110

 &(AND) - 두 비트가 모두 1이어야 1, 그 외에는 0
 |(OR) - 한 비트라도 1이면 1, 두 비트가 0이어야 0
 ~(NOT) - 모든 비트를 대상으로, 1은 0으로 0은 1로 바꾼다. (비트 반전 - 1의 보수 구할 때)
 ^(XOR) - 두 비트가 다르면 1, 같으면 0


#####################################################
#####################################################
bitset - #include <bitset>에 포함되어 있다.
	   - (정수 데이터)를 2진수로 변환한 것을 보여준다.
#####################################################
#####################################################


////////////////////////////////////////////////////////////////////////////////////////
case 7. 비트 단위 쉬프트(Shift) 연산자
- <<, >>
- cout, cin 객체와 만나면 추출 연산자로 의미가 바뀜.(연산자 오버로딩)

- 좌측 피연산자의 모든 비트열을 우측 피연산자 정수값만큼 이동시킨다.
- 자리수가 넘어가면 부호 비트가 변경되거나, 값이 소실된다.

- 좌측으로 이동하면 2^n배씩 증가함
- 우측으로 이동하면 (1/2)^n배씩 증가함.


연산 속도의 차이가 발생함.
/2 -> *0.5 -> >>1

양수/왼쪽  - "0"으로 채워짐
양수/오른쪽- "0"으로 채워짐

음수/왼쪽  - "0"으로 채워짐
음수/오른쪽- "1"로 채워짐

################################################################################

######
형변환
######

- 서로 다른 자료형이 규칙에 맞는 자료형으로 변환이 일어나는 것
- 대입 연산 기준 좌측 자료형으로 형 변환이 일어난다.

1. 묵시적 형 변환

double dTest = 123; // 123은 int형 정수
					// double형 실수 123.0으로 자동(묵시적) 형 변환이 일어난다.

int iTest = 3.1415; // 3.1415는 double형 실수
					// int형 정수 3으로 자동 형 변환이 일어난다.
					// (int)3.1415라고 써서 명시적 형 변환으로 바꾸는게 좋음.

2. 명시적 형 변환 - 경고 메시지를 차단할 수 있다.

int iTest = (int)3.1415; // double형 실수 3.1415를 int형 정수 3으로 명시적 형 변환을 한다.


####################
산술 연산 시 형 변환
####################

case 1. 정수와 실수 연산 - 실수형으로 형 변환(묵시적), 실수 우선 !!!!
case 2. 정수끼리, 실수끼리 연산 - 메모리가 큰 쪽으로 형 변환(묵시적)


################################################################################




*/


#include <iostream>
#include <bitset>

using std::cout;
using std::endl;
using std::bitset;

int main(void) {
	// 나눗셈은 일반적으로 생각하는 것과 같음.
	cout << "10/3 : " << (10 / -3) << endl; // -3
	cout << "11/ -3.0: " << (11 / -3.0) << endl; // -3.66667
	cout << "-1.2/ -2.0: " << (-1.2 / -2.0) << endl << endl; // 0.6

	// 우선 "X % Y" 연산이라고 생각하면, 부호 없이 계산한 뒤에 X의 부호에 맞춰주면 된다 !!!!
	cout << "-2% -255: " << (-2 % -255) << endl; // -2
	cout << "2% -255: " << (2 % -255) << endl; // 2
	cout << "-2% 255: " << (-2 % 255) << endl; // -2
	cout << endl;

	cout << "#############################################################################" << endl;

	// 자료형의 크기
	cout << "sizeof(char): " << sizeof(char) << endl;
	cout << "sizeof(bool): " << sizeof(bool) << endl << endl;  // 1 byte

	cout << "sizeof(short): " << sizeof(short) << endl << endl;

	cout << "sizeof(int): " << sizeof(int) << endl;
	cout << "sizeof(long): " << sizeof(long) << endl; // 4 bytes
	cout << "sizeof(float): " << sizeof(float) << endl << endl;

	cout << "sizeof(long long): " << sizeof(long long) << endl; // 8 bytes
	cout << "sizeof(double): " << sizeof(double) << endl; // 8 bytes
	cout << "sizeof(long double): " << sizeof(long double) << endl << endl;

	cout << "#############################################################################" << endl;

	char a = 'A';
	char b = 'B';
	cout << a << ", " << b << endl;
	cout << sizeof(a + b) << endl << endl; // 단일 문자 char형은 저장될 때 (int형 정수)로 임시 메모리에 저장됨.
										   // 그래서, 4 bytes
										   // 출력할 때만 자료형을 판단해서 단일 문자를 뿌려주는 것임.


	short c = 20;
	short d = 22;
	cout << c << ", " << d << endl;
	cout << sizeof(c + d) << endl << endl; // short도 마찬가지로 정수형 연산은 int형이 제일 빠르니까 4 bytes로 저장 됨.


	float e = 3.14f;
	float f = 3.14f;
	cout << e << ", " << f << endl;
	cout << sizeof(e + f) << endl << endl; // 애초에 형 변환 시켜준 상태라 4 bytes.

	double g = 3.14;

	cout << e << ", " << g << endl;
	cout << sizeof(e + g) << endl << endl;

	cout << "#############################################################################" << endl;

	// bitset : 정수 데이터의 2진수 비트 꼴로 보여준다.
	// "unsigned" 데이터인가 봄, 음수를 오른쪽 shift할 때 원래 "1"이 채워져야하는데...

	bitset<4> bitA = 16, bitB = 5, bitC = 0;
	cout << bitA << endl;
	cout << bitB << endl;

	bitC = bitA & bitB;
	cout << bitC << endl << endl;

	cout << "#############################################################################" << endl;

	// Shift 연산 시 채워지는 숫자 확인하기.
	bitset<16> bitD;

	bitD = -16;
	cout << "(-16): " << bitD << endl;
	cout << (bitD << 2) << endl; // 음수를 왼쪽 이동 0
	cout << (bitD >> 2) << endl << endl; // 음... 원래라면 1이 채워져야 할텐데..

	bitD = 240;
	cout << "(240): " << bitD << endl;
	cout << (bitD << 2) << endl; // 양수를 왼쪽 이동 0 채워짐.
	cout << (bitD >> 2) << endl << endl; // 양수를 오른쪽 이동 0 채워짐.

	cout << "#############################################################################" << endl;

	// Hello를 명시적 형 변환으로 출력하기
	cout << (char)72 << (char)101 << (char)108 << (char)108 << (char)111 << endl << endl;

	// 산술 연산 시 형 변환 방향.
	float fA = 3.14f;
	short nA = 10;

	cout << sizeof(fA + nA) << endl; // 정수와 실수의 연산이라 실수로 자동 형 변환이 된다.

	int iA = 10;
	long long llA = 20;

	cout << sizeof(iA + llA) << endl; // 같은 정수형이지만 메모리 큰 쪽으로 자동 형 변환이 된다.

	cout << sizeof(llA + fA) << endl; // 실수 연산이 더 우선이라 4 bytes

	cout << "sizeof(long long): " << sizeof(long long) << endl;

	return 0;
}
