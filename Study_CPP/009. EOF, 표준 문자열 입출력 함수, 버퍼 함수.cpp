/*

2019.04.03.01 수


########################
   EOF (End Of File)
########################

- 파일의 끝을 표기하기 위해 #define으로 정해놓은 상수
- 문자열의 끝을 알리기 위해서는 '\0' 문자를 사용 했음.

- 문자 입력에 실패 했을 때, 반환 받는 값 (-1)
- 컴파일러(시스템)에 따라서 char 형이 unsigned char로 되어있는 경우가 있어서 음수 "-1"인 EOF를 사용하지 못한다 !!!!


###############################################
 Ctrl + z 는 EOF를 입력할 수 있는 단축키 !!!!
###############################################


문자 입출력의 반환 값이 int인 이유
- char 형은 시스템에 따라 unsigned가 될 수 있다.
- char형은 unsigned가 되면 EOF를 표현할 수 없다.
- 그래서 int는 signed를 유지하므로 int를 사용하기로 함.


#############################################################################################################


##############################
    표준 문자열 입출력 함수
##############################


#####################################
  문자열 출력 함수 puts(), fputs()
#####################################

case 1. puts()
- 출력 스트림이 표준 출력 스트림 stdout으로 고정되어 있다.
- 자동적으로 개행(new line)을 해준다 !!!!

int puts(const char *_Buffer);

매개변수 const char *_Buffer : 입력받은 문자열을 전달을 위해 (char *) 형
반환값 int : 성공 시 음수가 아닌 값, 실패 시 EOF


case 2. fputs()
- 출력 스트림을 지정해줄 수 있다.
- 개행(new line)이 되지 않는다.

int fputs(const char *_Buffer, FILE *_Stream)

매개변수 const char *_Buffer :
매개변수 FILE *_Stream : 
반환 int - 실패 시, EOF



#####################################
  문자열 입력 함수 gets_s(), fgets()
#####################################


case 1. gets_s()
- (입력 받을 문자열의 크기 - 1)이 문자열을 저장할 메모리 공간의 크기를 넘어가면 Runtime 오류 난다 !!!!

char* gets_s(char *_Buffer, rsize_t _Size);

매개변수 char *_Buffer : 문자열을 저장할 메모리 주소
매개변수 rsize_t _Size : 입력 받을 문자열의 크기 // rsize_t = size_t = unsigned int
반환값 char* : 입력 받은 문자열의 주소를 넘겨주기 위해서...
               입력 받은 문자열이 없이 EOF를 만났다면, NULL 반환.


#######################
   cin vs. gets_s()
#######################

- "white space"를 처리 하지 않음.
but, get_s()는 그런 것 없음. 다 읽어온다.
그리고, '\n' 문자는 '\0' 문자로 바꿔서 문자열에 넣어준다 !!!!




case 2. fgets()
- "Enter" 값까지 읽어들인다.
- 입력 받을 문자열의 크기가 문자열을 저장할 메모리 공간의 크기를 넘어가면,
"해당 저장 공간의 크기 - 1(NULL 문자 크기)"만큼만 읽어오고 나머지는 입력 스트림 버퍼에 남는다 !!!!

char* fgets(char *_Buffer, int _MaxCount, FILE *_Stream);

매개변수 char *_Buffer : 입력 받을 문자열을 저장할 메모리 주소
매개변수 int _MaxCount : 입력 받을 문자열 크기(메모리 공간의 크기보다 작아야 함.)
매개변수 FILE *_Stream : 입력 스트림의 FILE 구조체 포인터
반환값 char* : 입력 받은 문자열의 주소를 넘겨주기 위해서...
               입력 받은 문자열이 없이 EOF를 만났다면, NULL 반환.



##################################
   gets_s()와 fgets()의 차이점
##################################

gets_s() : "Enter" 값을 읽어오지 않음. 크기가 초과되면 Runtime 오류 난다. 
fgets() : "Enter" 값도 읽어온다. 그러나, (설정한 사이즈 - 1_'\0'문자)만큼만 읽어오고 나머지는 버퍼에 남긴다 !!!!


#############################################################################################################

#######################
       버퍼 함수
#######################

- 데이터를 임시 저장하기 위한 메모리 block을 Buffer !!!!
- 이러한 메모리 block인 Buffer를 비울 수 있는 함수가 버퍼 함수.


#######################################################################################
- "비우다"의 의미는 "삭제"가 아닌 "버퍼에서 목적지로 이동시키면서 비운다"라는 의미 !!!!
#######################################################################################

- 입출력 스트림 버퍼를 비우는 함수는 표준 함수가 아님.
So, 컴파일러마다 사용 가능 유무가 다름 ㅋㅋㅋㅋ.

출력 버퍼 비우기 fflush();
- 출력 버퍼를 비우는 용도라서 입력 버퍼는 비우지 않는다.
- 출력 버퍼를 비우는 작업은 많이 하지 않는다.



###################################
입력 버퍼 비우기 함수가 필요한 이유
###################################

- 입력 버퍼를 비우는 함수는 없기 때문에 만들어야 함.


##########################
while (getchar() != '\n'); // 입력의 마지막은 "Enter"이기 때문에...
##########################



#############################################################################################################


*/


#include <iostream>

using std::endl;
using std::cout;
using std::cin;

int main(void) {

	cout << "##############################################################################" << endl;
	cout << "### EOF_ End Of File" << endl << endl;

	//while (true) {

	//	char ch = getchar(); // 엔터도 읽기 때문에, 한 줄씩 띄어지는 것임.

	//	if (ch == EOF) { // Ctrl + z 는 EOF를 입력할 수 있는 단축키.
	//					// 입력을 그만 받을 것이니까...
	//		break;
	//	}

	//	putchar(ch);
	//}

	system("pause");
	cout << "##############################################################################" << endl;
	cout << "### gets_s(), puts()" << endl << endl;

	char input[3] = "";

	gets_s(input, sizeof(input)); // "Enter"는 입력으로 넣어주지 않고, '\0' 문자로 바꿔준다.
								  // (입력 받을 공간의 크기 - 1)을 넘어가는 입력은 Runtime 오류

	puts(input); // 자동으로 개행한다 !!!!!!

	cout << "##############################################################################" << endl;
	cout << "### fgets(), fputs()" << endl << endl;

	char input2[3] = "";
	
	fgets(input2, sizeof(input), stdin); // (입력 받을 공간의 크기 - 1)을 넘어가는 입력 버퍼에 남는다.
										// 그래서 입력 스트림 버퍼를 비워주는 작업이 필요하다 !!!!!

	fputs(input2, stdout); // 자동으로 개행이 안됨 !!!!!


	cout << "##############################################################################" << endl;
	cout << "### 버퍼 함수" << endl << endl;

	//char id[4] = "";
	//char name[16] = "";
	//
	//fgets(id, sizeof(id), stdin); // 먼저 입력받을 때, 크기를 넘어서 받아버리면...
	//
	//
	//while (getchar() != '\n'); // 입력의 마지막은 
	//
	//
	//
	//fgets(name, sizeof(id), stdin); // 입력 스트림 버퍼에 남아있는 값들을 읽어오기 때문에
	//								// 새로운 입력을 받을 기회조차 없음.
	//
	//fputs(id, stdout); // "Enter?!"
	//fputs(name, stdout);

	
	cout << "##############################################################################" << endl << endl;


	return 0;
}