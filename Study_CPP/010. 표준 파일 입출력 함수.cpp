/*

2019.04.03.02 수

##############################
    표준 파일 입출력 함수
##############################


######################
  파일 입출력 스트림
######################

- console 입출력에는 운영체제가 자동으로 스트림을 생성하고 소멸시켜줬다.
- file 입출력은 운영체제에게 부탁을 해야함.
(스트림 자체가 시스템 자원의 한 종류이기 때문이다.)


####################
  파일 경로의 종류
####################

절대 경로 : 최초의 시작점으로 경유한 경로를 전부 기입하는 방식

상대 경로 : 기준이 되는 곳에 따라 유동적으로 바뀜. (여기서는 "cpp" 파일 기준으로?!)


#########################
 표준 파일 입출력 함수 - fopen_s(), fclose()
#########################

#####################
  case 1. fopen_s()
#####################

- 파일을 열고, 스트림의 생성을 요청한다.
- 파일 개방이라고 부른다
- 파일 개방 성공 시 "0"을 반환, 실패 시 "0"이 아닌 값 반환 !!!

- 출력 스트림을 파일에 연결하고 출력 해버리면 파일에 값들이 들어간다 !!!!

FILE - 구조체로 선언 된 것이고, 파일을 가리키는 지시자.

매개변수 FILE **_Stream : 
const char *_FileName : 파일의 경로와 이름, 확장자를 포함한 문자열을 전달한다.
const char *_Mode : 입출력 스트림의 종류를 정해준다.
반환값 errno_t : int 형이고, 파일 개방 성공 시 "0", 실패 시 원인에 따른 "0"이 아닌 값을 반환한다.


####################
  case 2. fclose()
####################
- 스트림 이용이 끝나면 파일을 닫고 스트림 소멸을 요청한다.
- 동적할당 해제와 동일하게 메모리 누수를 방지하는 차원에서 꼭 사용할 것.


#############################################################################################################

#####################
   파일 개방 모드
#####################

- "r"(read) : 읽기 모드(파일 없으면 개방 안됨)
- "w"(write) : 쓰기 모드(파일 없으면 생성)
- "a"(append) : 덧붙여 쓰기 모드(파일 없으면 생성)
- "+" : 스트림을 읽기/쓰기 모두 사용할 수 있도록...
(두 가지 모두를 사용할 수 있지만, 읽기와 쓰기 작업을 번갈아가며 할 때, 버퍼에 대한 처리를 잘 해줘야 함.)

- "t"(text) : 일반적인 text 형식
- "b"(binary) : 그림, 영상, 음원 등 text로 표현할 수 없는 형식을 처리함.
(속도는 binary 모드가 더 빠르다.)

#############################################################################################################

###############################
   파일 입출력 시 개행 문제
###############################

- C 언어에서는 개행이 "\n"을 의미함.

운영체제에 따라 개행 문자를 다르게 표기하고 있다.
멀티 플랫폼에서는 진짜 조심해야 함 !!!!

- Windows에서는 "\r\rn"
- unix에서는 "\n"
- mac에서는 "\r"

So, 개행 문자가 포함되는 데이터의 저장에는 주의한다 !!!!


파일 개방 시 text 모드로 진행하면 운영체제에 맞게 자동으로 변환된다.
but, binary 모드는 해당 되지 않는다...



#############################################################################################################

############################
   binary 모드의 입출력
############################



###############
   출력 함수 - 파일에 데이터를 넘겨주겠다.
###############

case 1. fwrite()

매개변수 const void *_Buffer : 출력할 메모리의 시작 주소를 넘겨 받음.
매개변수 size_t _ElementSize : 출력할 메모리의 크기(넘겨줄 데이터의 크기)
매개변수 size_t _ElementCount : 출력할 메모리의 개수
매개변수 FILE *_Stream : 개방한 스트림의 종류
반환값 size_t : 성공 시 count를 반환, 실패 시 count 보다 작은 값 반환.


###############
   입력 함수 - 파일에게서 데이터를 받겠다.
###############

case 1. fread()

매개변수 void *_Buffer
매개변수 size_t _ElementSize :
매개변수 size_t _ElementCount :
매개변수 FILE *_Stream : 개방한 스트림의 종류

반환값 size_t


#############################################################################################################

####################################
   binary 모드의 입출력의 좋은 점
####################################

- 배열, 구조체 등의 연속된 메모리 공간을 갖는 자료형은 시작 주소와 크기를 알 수 있기 때문에,
binary 입출력을 통해 데이터를 통째로 저장 및 불러 올 수 있다.

- binary 데이터는 컴퓨터가 인식하기 쉬우므로, 성능상의 이점이 있다.
(음원, 영상, 이미지 파일 등이 용이함.)


######################   꼭 확인할 것   ############################

- 단, 포인터 배열 혹은 구조체의 멤버로 포인터를 들고 있을 경우에
다른 데이터를 불러올 수 있는 점에 주의하자 !!!!
(프로그램 실행 시 해당 변수의 주소가 달라지니까...)

####################################################################


#############################################################################################################

과제.

textRPG 기능 추가
- 레벨, 경험치
- save & load 기능 (binary 데이터)

*/


#include <iostream>

using std::endl;
using std::cout;
using std::cin;

int main(void) {

	cout << "##############################################################################" << endl;
	cout << "### 표준 파일 입출력 함수" << endl << endl;

	FILE *fp = nullptr;
	errno_t err = fopen_s(&fp, "./test.txt", "wt");

	if (err == 0) {

		fputs("Hello", fp); // 출력 스트림을 fp에 저장된 파일로...
							// 그래서, 파일에 해당 문자가 들어간다.

		cout << "파일 개방 성공" << endl;
		fclose(fp);
	}
	else {

		cout << "파일 개방 실패" << endl;
	}
	cout << endl;

	cout << "##############################################################################" << endl;
	cout << "### 파일에서 문자열 받아오기" << endl << endl;

	char buffer[32] = "";
	FILE *fp2 = nullptr;
	errno_t err2 = fopen_s(&fp, "./test.txt", "rt");

	if (err2 == 0) {

		fgets(buffer, sizeof(buffer), fp); // 입력 스트림을 fp에 저장된 파일에 연결하고 buffer에 입력 받음.

		cout << "파일 개방 성공" << endl;
		fclose(fp2);
	}
	else {

		cout << "파일 개방 실패" << endl;
	}

	cout << buffer << endl << endl;

	cout << "##############################################################################" << endl;
	cout << "### binary 모드의 입출력" << endl << endl;

	int arr[5] = { 1, 2, 3, 4, 5 };
	FILE *fp3 = nullptr;
	errno_t err3 = fopen_s(&fp, "./binary.txt", "wb");

	if (err3 == 0) {

		fwrite(arr, sizeof(arr), 1, fp); // 배열을 통째로 넘겨줌.
		//fwrite(arr, sizeof(int), 5, fp); // int 형 자료를 1개씩 모두 넘겨줌.

		cout << "파일 개방 성공" << endl;
		fclose(fp3);
	}
	else {
		
		cout << "파일 개방 실패" << endl;
	}

	int arr2[5] = {};
	fp3 = nullptr;
	errno_t err4 = fopen_s(&fp, "./binary.txt", "rb");

	if (err4 == 0) {

		fread(arr2, sizeof(arr2), 1, fp);

		cout << "파일 개방 성공" << endl;
		fclose(fp3);
	}
	else {

		cout << "파일 개방 실패" << endl;
	}

	for (int i = 0; i < 5; i++) {
		cout << arr2[i] << " ";
	}
	cout << endl << endl;

	cout << "##############################################################################" << endl;


	return 0;
}