/*


########################
    레퍼런스 자료형 - 참조자(reference)
########################

- 메모리에 접근하는 방법으로 포인터의 간접 참조를 통해 접근했다.
- 레퍼런스 자료형은 원본 메모리에 직접 접근하는 방법이다.

변수에 또 다른 이름을 부여하는 것과 같은 것이다.

- 원본 메모리 공간을 의미하는 자료형과 일치 시켜야 한다.

  ##################################
- 선언과 동시에 다른 변수로의 초기화가 이루어져야 한다. "NULL 초기화"가 존재하지 않는다.
  ##################################

ex.

int num = 10;
int *ptr = &num; // 포인터
int &ref = num; // 참조자, 레퍼런스

- "num"이라는 이름으로 메모리 할당 받은 메모리 공간애,
 "ref"라는 또 다른 이름을 부여하는 것이다.

그래서, "num"과 "ref"는 같은 주소를 가지고 있는 것 !!!!


ref = 42;
- 원본에 직접 접근하여 값을 변경할 수 있다.


#############################################################################################

##############################
   reference와 const 키워드
##############################

const int num3 =  20;
int &ref3 = num3; // 컴파일 오류, 왜냐하면 "const" 키워드가 없어서, 변경 가능성이 있으니까 !!!!
const int &ref3= num3; // 가능함 !!!!


#############################################################################################

############################
   reference와 리터럴 상수
############################

const int &ref = 20; // 임시 메모리에 저장되어 있는 리터럴 상수를 가리킬 수 있다.

if) 코드 라인을 벗어나면 리터럴 상수는 소멸된다.
but, "reference"를 이용하면 이름을 지어주는 것이기 때문에, 임시 변수를 생성하는 것과 같은 기능이다.


#############################################################################################

###############################
  reference와 함수의 매개변수
###############################

ex.

int Add(int &a, int &b)
{
	return a + b;
}

인자 전달 시 매개 변수가 메모리를 잡지 않고, 원본을 그대로 받는다.
but, 매개변수가 "int &a"라서 리터럴 상수의 값을 넣으면 컴파일 오류.

그래서, 상수까지 받아오려면....

int Add(const int &a, const int &b)
{
	return a + b;
}


##########################
     reference의 크기
##########################

- 진짜로 메모리 크기가 있는 것은 아니고...
 가리키고 있는 자료형의 크기가 나올 뿐...

- reference의 크기는 개념상 "0"이라고는 하지만...
솔직히 논의할 가치는 없을듯.

#############################################################################################

*/

#include <iostream>

using std::cout;
using std::endl;


int main(void)
{
	cout << "#######################################################################" << endl;
	cout << "### reference(참조자)의 선언과 초기화" << endl << endl;

	int num = 10;
	int *ptr = &num;
	int &ref = num;


	cout << "&num: " << &num << endl;
	cout << "&ref: " << &ref << endl << endl;

	ref = 42;
	cout << "num: " << num << endl;
	cout << "ref: " << ref << endl << endl;

	cout << "#######################################################################" << endl;
	cout << "### reference(참조자)를 이용한 대입 연산" << endl << endl;

	int num1 = 10, num2 = 20;
	int &ref2 = num1; // ref2: num1이라서 10

	ref = 50; // num1: 50

	ref = num2; // num1: 20 "값"만 대입 받는 것임.
				// 선언과 동시에 초기화할 당시에만 가리키는 변수를 지정하는 것임.

	ref = 999; // num1: 999

	cout << "num1: " << num1 << endl;
	cout << "num2: " << num2 << endl << endl;


	cout << "#######################################################################" << endl;
	cout << "### " << endl << endl;

	struct A
	{

	};

	cout << "sizeof(A): " << sizeof(A) << endl << endl; // 주소가 겹치지 않게 하기 위해서 구조체는 최소 1.

	struct B
	{
		int &b;
	};

	cout << "sizeof(B): " << sizeof(B) << endl; // 4, 임시 포인터의 크기를 의미 함.
												// reference는 크기가 없다 !!!!!

	return 0;
}
