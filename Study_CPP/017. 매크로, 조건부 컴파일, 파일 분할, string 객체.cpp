/*

#pragma waring(disable:4996)

##########################
      매크로(Macro)
##########################

- 전처리 단계에서 프로그램 코드의 단순 치환의 형태로 이루어진다.
(전역으로 사용함)

- 그리고, 세미콜론 ";"까지 쓰면 같이 치환 되어 프로그램 코드에 들어가므로 붙이면 안됨 !!!
(그리고 문자의 끝을 의미하는 것도 아님.)


ex.

#define 매크로명 치환할 문장

# : 전처리 지시자


#################
   매크로 상수
#################
#define PI 3.14f
(세미 콜론 ";" 없음 !!!!)


##############################
if) 치환할 문장이 없는 경우?!
##############################

#define NUM  // 치환 해줄 문장이 없음.

- 치환할 문장이 없기 때문에, 해당 부분은 공백으로 처리가 된다.

So, cout << PI2 << endl; 라는 문장이
cout << << endl; 가 되어서 컴파일 오류가 된다 !!!!


################
   매크로 함수
################

- 함수명(매개변수)만 넣어주면 됨.

ex.

#define SQUARE(X) X * X

- 실질적으로 매개변수의 대상이 숫자...
but, expression이나 문자열이 들어간다면 문제가 발생.


case 1. expression

SQUARE(2 + 2)
- 2 + 2 * 2 + 2 이런 방식으로 단순 치환이 되어 원하는 결과가 아니다.
(연산자의 우선순위를 생각한 치환이 아니기 때문이다...)

so, 소괄호를 사용하여 예방한다.

#define SQUARE(X) (X) * (X)


case 2. 문자열

- 컴파일 오류 발생?!
but, 치환 문장에 #을 매개변수 앞에 붙이면 치환은 가능함.

###########################
 두 줄 이상의 매크로 문장
###########################

- "\"를 이용하여 두 줄 이상의 문장을 표현할 수 있다.

ex.

#define SQUARE(X) \
(X) * \
(X)

- 역 슬래쉬 "\" 뒤에 공백 문자가 오면 컴파일 오류 뜬다 !!!
그리고, 사용하지 않는다면 무조건 한 줄로만 인식이 된다.


########################
   매크로 함수의 장점
########################

A. 자료형에 의존적이지 않다.
- 단순 치환이라서 자료형에 따른 함수들을 선언할 필요가 없다.

B. 일반적인 함수 호출에 비해 속도가 빠르다.
(전처리 단계에서 이미 프로그램 코드로 들어감
일반 함수는 함수 call이 있기 때문에 overhead가 발생함.)


########################
   매크로 함수의 단점
########################

A. 디버깅이 어렵다.
- 디버깅 단계에서 변수들의 변화 과정을 파악하기 쉽지 않기 때문에...

B. 복잡한 함수를 구성하기에는 어렵다.
- 호출 빈도수가 높은 함수들 중 구현이 간단하다면 매크로 함수를 사용한다.

ex. 그렇지만 매우 번거롭다 ㅋㅋㅋㅋ.

#define DLELET_MEM(p) \
if(p) \
{ \
delete p; \
p = nullptr; \
}

같은 효과.

if(p)
{
	delete p;
	p = nullptr;
}


##############################################################################################################

###################
   조건부 컴파일
###################

- 전처리 단계에서 해당 조건에 따라서 컴파일 여부가 결정된다.
(조건에 대한 값을 입력하는 행위는 불가. Runtime도 아닌데 어찌 값을 받음 ㅋㅋㅋ)


###########
case 1. #if
###########
- 조건문 if와 같은 기능.
- #if의 영역을 지정 해줘야 한다.

ex.

#if 5 > 7 
	cout << "조건이 참" << endl;
#elif 5 > 2 // else if와 같은 기능.
	cout << "두 번째도 참 << endl; // 조건이 참이기 때문에 컴파일이 된다. 색깔 차이도 난다 !!!!
#else
	cout << "조건이 거짓" << endl;
#endif


##############
case 2. #ifdef
##############
- #define으로 정의되어 있으면 실행해라.

ex.

#define MAX_SIZE

#ifdef MAX_SIZE
	cout << "MAX_SIZE 정의 됨" << endl;
#endif


ex. 치트 코드를 넣어 테스트를 하기 위해서..

// 속성에서 - C/C++ - 전처리기 - 전처리기 정의(Debug/ Release) _DEBUG, NDBUG

모드를 Release로 바꾼 뒤에

#ifdef _DEBUG
	cout << "치트 코드" << endl;
#endif

but, 모드를 Debug로 바꾼다면 수행이 된다 !!!!


###############
case 3. #ifndef
###############
- #ifdef와 반대의 의미
- #define으로 정의되어 있지 않다면 실행해라.


##############################################################################################################

########################
       파일 분할
########################

- 프로젝트의 규모가 커질 수록 기본 로직만 해도 프로그램 코드가 길어지고 관리가 어려워짐.

- header file - 함수의 선언부, 매크로, 구조체 등을 모아놓은 파일.
- source file - 함수의 정의부[body]와 같은 실질적인 구현 로직들을 모아 놓은 파일.

- header 파일과 source 파일은 이름은 같고, 확장자만 다르면 됨(".h", ".cpp").


##########################
  파일 분할 시 주의 사항
##########################

- 각 파일을 독립적으로 컴파일 할 수 있도록 필요한 선언을 포함해야 한다.
(source 파일에 필요한 선언들을 #include "헤더파일명"으로 header 파일을 포함시켜야 한다.)

ex. #include <표준 헤더파일>
    #include "사용자가 만든 헤더파일"

#####################################################
In C 언어
- header 파일에 함수의 정의부[body]를 두어선 안된다.
- header 파일에 전역 변수를 선언할 수가 없다 !!!!

but, C++에서는 가능하다 ?!
#####################################################


########################################
    header 파일 중복 포함에 따른 오류
########################################

- header 파일을 엮는 과정에서 발생하는 오류 !!!!
- 다양한 파일들을 대상으로 프로그래밍할 때,
header 파일을 중복 포함한다면, 동일한 변수명, 동일한 함수가 포함되므로...



####################
case 1. #pragma once
####################
- 중복 선언된 header로 인한 꼬임 현상을 방지하기 위해 사용한다.
- 최초에 한 번만 정의하게 만든다.
- 표준이 아니라서 컴파일러에 따라 지원을 하지 않는 경우가 있다.


#############################
case 2. 조건부 컴파일 #ifndef
#############################

ex.
#pragma once

#ifndef _ARRAY_LIST_H_ // 최초에 수행하면, 아래에서 header 파일을 정의를 하기 때문에...
#define _ARRAY_LIST_H_ // 이후에 다른 파일에서 해당 header 파일을 포함한다고 해도 수행되지 않는다 !!!!

	...
	...

#endif


##############################################################################################################

##################
   string 객체
##################

- 템플릿 클래스(template class)이고, 컨테이너(container)라고도 한다.

- 문자열 복사, 결합, 비교에 있어서 이전에는 문자열 처리 함수를 사용했음.
but, string 자료형은 쉽게 문자열 처리할 수 있다.

- #include <string> header 파일을 포함해야 사용할 수 있다.
물론, using std::string; 도 포함 해줘야 함 !!!


##############################################################################################################


*/


#include "stdafx.h"

// #include <string> // string 자료형을 사용하기 위해서 포함시켜야 함.

#define PI 3.14f // 매크로 상수
#define PI2 // 치환해줄 문장이 없음 !!!!

#define SQUARE(X) X * X

#define SQUARE2(X) \
X * \
X


int main(void)
{
	cout << "##################################################################################" << endl;
	cout << "### 매크로 상수" << endl << endl;

	cout << "매크로 상수 PI: " << PI << endl << endl;
	//cout << "매크로 상수 PI: " << 3.14f << endl; // 전처리 단계에서 프로그램 코드가 대체된다.


	//cout << PI2 << endl; // 컴파일 오류, 치환해줄 문장이 없는 경우 빈 공간으로 대체 된다 !!!!

	cout << "##############################################################################" << endl;
	cout << "### 매크로 함수" << endl << endl;

	cout << "매크로 함수 SQUARE(5): " << SQUARE(5) << endl;
	//cout << "매크로 함수 SQUARE(5): " << 5 * 5 << endl; // 치환되어 들어갔음.

	//cout << "매크로 함수 SQUARE(5): " << SQUARE("Hello") << endl; // 숫자 대상이라서 문자열이 오면 컴파일 오류
	//cout << "매크로 함수 SQUARE(5): " << SQUARE('A') << endl; // 단일 문자는 되긴 하는데 의미가 없음 ㅋㅋㅋ.

	cout << "매크로 함수 SQUARE2(5): " << SQUARE2(5) << endl;

	cout << "##############################################################################" << endl;
	cout << "### string 자료형 선언과 초기화" << endl << endl;

	string str1; // 자동으로 "0", NULL 초기화, 아무것도 없음.
	string str2 = "Hello"; // 대입 연산으로 초기화
	string str3("World"); // 객체라서... C++ 초기화 문법(변수 뒤에 소괄호를 이용하여 초기화 한다.)

	cout << str1 << endl;
	cout << str2 << endl;
	cout << str3 << endl << endl;


	cout << "##############################################################################" << endl;
	cout << "### string 객체의 문자열 처리" << endl << endl;

	str1 = str2; // case 1. 문자열 복사(대입)

	str1 = str2 + str3; // case 2. 문자열 결합 "+' 연산자의 오버로딩 때문에 가능함.
	// str1 = str2;
	// str1 += str3; 같은 기능을 함.

	str1 = str2;
	if (str1 == str2) // case 3. 문자열 비교. "==" 연산자의 오버로딩 때문에 가능함.
	{
		cout << "string 문자열이 같음." << endl;
	}
	else
	{
		cout << "string 문자열이 다름." << endl;
	}

	cout << "문자열 str1 길이: " << str1.length() << endl;// 문자열 길이(string 객체의 멤버 함수)


	// string 객체를 char 형 문자열로 바꾸는 과정 !!!!
	const char *str = str2.c_str(); // 자료형이 (const char *)
	
	cout << "string 객체 -> char 형 문자열: " << str << endl;

	str1 = str;
	cout << "char 형 문자열 -> string 객체: " << str << endl;


	cout << "sizeof(string): " << sizeof(string) << endl; // char 형 문자열 보다 메모리를 더 잡아먹는다고?! 28 Bytes?

	str1.append(str3); // concatenate 기능
	cout << str1 << endl;

	cout << "##############################################################################" << endl;

	return 0;
}
