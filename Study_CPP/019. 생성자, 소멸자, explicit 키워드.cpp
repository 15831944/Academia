///*
//
//2019.04.16.01 화
//
//############################
//   성적표 클래스 과제 풀이
//############################
//
//A. 3단계 구성(main 함수에 들어가야할 내용)
//- 초기화(생성자)
//- 구현 로직
//- 메모리 해제(소멸자)
//
//
//B. 추상화 단계를 더 높였네.
//
//학생(구조체)이랑 성적표(클래스)랑 헤더파일을 나눴음.
//그리고, Main Progress 클래스도 있음.
//(성적표 기능을 public으로 받아서 쓴다.)
//
//
//C. 매크로 함수를 통해서 메모리 해제 과정을...
//
//
//D. 학생 수를 추가로 받을 때, nullptr 비교로 처음인지 확인.
//아니면, temp 배열을 만들고 복사하고 메모리 해제하고 대입하고...
//
//
//##################################################################################################
//
//##############################################
//   생성자(Constructor)와 소멸자(Destructor)
//##############################################
//
//case 1. 생성자(Constructor)
//
//- 클래스의 이름과 같으며, 반환형이 없는 함수와 같은 형태.
//- 매개변수의 차이에 따라 다른 생성자가 된다.(Overloading 개념 추가)
//
//- 클래스 외부에서 객체를 생성하기 위해서, 생성자는 주로 public으로 Access Modifier를 지정해준다.
//
//- 객체 생성 시, 생성자는 반드시 호출된다.(컴파일러가 추가해주는 default constructor가 존재하기 때문에)
//
//- constructor는 객체 멤버들을 초기화 하는데 주로 사용된다.
//
//##############################################################################
//- 생성자는 주로 "0" 초기화, init 함수는 의미있는 값을 넣어주는 용도로 쓴다고?!
//##############################################################################
//
//
//#######################
//  Default Constructor
//#######################
//
//- 매개변수가 없고, 컴파일러에 의해 자동으로 생성되는 constructor를 의미한다.
//- 사용자가 임의로 생성자를 구현했다면, 컴파일러가 default 생성자를 만들지 않는다 !!!!
//
//########################################################
//- 모든 객체의 생성은 생성자 호출에 의해 완성이 된다 !!!!
//########################################################
//
//
//###############################
//case 1. [default] 생성자의 정의
//###############################
//class Student {
//
//public:
//	Student() { // default 생성자
//		cout << "디폴트 생성자" << endl;
//	}
//}
//
//int main(void) {
//
//	Student std1; // 객체 생성 시, 생성자는 반드시 호출된다.
//				  // 매개변수로 해당 생성자를 찾지 못할 경우, 컴파일 오류.
//	cout << "main 함수" << endl;
//
//}
//
//#########################################
//case 2. 매개변수가 존재하는 생성자의 정의
//#########################################
//class Student {
//
//public:
//	Student(int num) {
//		cout << "매개변수 존재하는 생성자"<<endl;
//	}
//}
//
//int main(void) {
//
//	Student std2(100); // 객체 생성 시, 생성자는 반드시 호출된다.
//					   // 매개변수로 해당 생성자를 찾지 못할 경우, 컴파일 오류.
//					   // 객체 생성 시 "()"를 통해 인자를 넘겨줄 수 있다.
//					   // 물론, overloading 개념을 통해 Default Constructor도 만들 수 있음.
//
//	cout << "main 함수" << endl;
//}
//
//##################################################################################################
//
//######################################
//   if) 멤버 변수를 초기화 하는 방법
//######################################
//물론, Operator overloading을 했으니까 가능함 !!!!
//
//Student std2 = 100; // in C, 일반 자료형이 아닌데 대입하니까 혼동을 할 수도...
//					// "std2 = 100;"이라는 문장이 "std2(100);" 의 형태로 
//					// Implicit 형 변환이 일어나기 때문에?!
//
//Student std3(200); // in C++
//
//
//
//###################
//  explicit 키워드
//###################
//
//- 생성자에 "explicit" 키워드를 사용하면, 대입 연산에 의한 생성자의 Implicit 호출을 막는다.
//So, Student std2 = 100; 형태는 불가능.
//오로지 Sutdent std2(100); 형태로 하도록 !!!!
//
//ex.
//class Student {
//
//public:
//	explicit Student(int num) {
//		cout << "매개변수 존재하는 생성자"<<endl;
//	}
//}
//
//##################################################################################################
//
//case 2. 소멸자(Destructor)
//
//- 객체 소멸(delete) 시, 반드시 호출 되는 함수이다. (컴파일러에 의해 default destructor가 생성된다.)
//(정적 객체는 프로그램이 종료되거나 delete 연산자로 메모리를 해제할 때...
//동적 객체는 delete 연산자로 메모리 해제할 때 !!!!)
//
//- 물론, 클래스 외부에서 접근해서 객체의 소멸을 하도록, 주로 public으로 Access Modifier를 지정해준다.
//(주로, 메모리 동적 할당을 받은 멤버의 메모리를 해제할 때 사용한다.)
//
//(메모리 해제하는 함수를 소멸자에 넣어서 사용하는 것이 오히려 좋을 수도?!
//- 로직에 따라서 다르겠지만, 도중에 메모리를 해제할 필요가 있을 경우...)
//
//- Destructor는 overloading이 불가능하다 !!!!
//
//
//ex. [default] 소멸자의 정의
//
//class Student {
//
//	~Student() {
//
//		cout << "디폴트 소멸자" << endl;
//	}
//}
//
//
//##################################################################################################
//
//#########################################
//   메모리 동적 할당 방식과 Constructor
//#########################################
//
//in C++
//- new 연산자를 사용하여 class를 메모리 동적 할당할 경우, 생성자가 호출된다.
//- delete 연산자를 사용하여 메모리 해제할 경우, 소멸자가 호출된다.
//
//in C
//- malloc(), calloc() 함수를 이용한다면, 생성자가 호출 되지 않는다.
//- free() 함수를 통해 메모리 해제를 하면, 소멸자가 호출 되지 않는다.
//
//
//##################################################################################################
//
//##############################
//     생성자와 소멸자 정리
//##############################
//
//case 1. 객체 생성 과정
//- 메모리 할당 - 생성자 호출 - 객체 생성
//
//
//case 2. 객체 소멸 과정
//- 소멸자 호출 - 메모리 반환 - 객체 소멸
//
//
//##################################################################################################
//
//
//*/
//
//#include "stdafx.h"
//
//class Student {
//
//private:
//	int num;
//
//public: // 주로, 생성자와 소멸자는 public
//	Student() { // Default constructor 형태.
//				// 아무 생성자도 정의가 되어 있지 않으면, 컴파일러가 자동으로 추가해준다.
//		num = 0;
//		cout << "Default 생성자: " << this->num << endl;
//	}
//
//	Student(int num) { // 매개변수가 있는 Constructor
//
//		this->num = num;
//		cout << "매개변수 있는 생성자: " << this->num << endl;
//	}
//
//	~Student() { // Destructor는 overloading 안 된다 !!!!
//
//		cout << "Overloading 안 되는 소멸자: " << this->num << endl;
//	}
//
//};
//
//class ExplicitConstructor {
//
//public:
//	explicit ExplicitConstructor(int num) { // 생성자에 추가한 explicit 키워드는 해당 클래스의 객체에 대한 대입 연산이
//											// implicit 형 변환으로 생성자 형태를 가질 수 없게 한다 !!!!
//
//		cout << "explicit 생성자는 대입으로는 호출 안 됩니다." << endl;
//	}
//
//};
//
//int main(void) {
//
//	cout << "#####################################################################################" << endl;
//	cout << "### Constructor & Destructor" << endl << endl;
//
//	Student std1;
//	Student std2 = 100; // 일반 자료형이 아니기 때문에, 정확히 무엇을 의미하는지 파악하기가 어려움.
//						// 그래서, 이 과정을 막아야 함.
//	Student std3(200);
//
//	// 생성자는 std1 -> std2 -> std3 소스 코드 순서로 호출
//	// but, 소멸자는 std3 -> std2 -> std1 객체 생성 순서와 반대로 호출된다 !!!!
//	// 스택을 생각하면 이해하기 쉬움.
//	cout << endl;
//
//	Student *ptr1 = new Student(); // 프로그램이 종료되어도, 소멸자 호출 안되네?!
//	Student *ptr2 = new Student(400);
//	cout << endl;
//
//	if (ptr1 != nullptr) { // 메모리 동적 할당 받은 객체는 delete 연산자를 통해 메모리 반납을 해야 소멸자를 호출한다 !!!!
//
//		delete ptr1;
//		ptr1 = nullptr;
//	}
//
//	if (ptr2 != nullptr) {
//
//		delete ptr2;
//		ptr2 = nullptr;
//	}
//
//	cout << "#####################################################################################" << endl;
//	cout << "### Explicit 키워드와 Constructor" << endl << endl;
//
//	ExplicitConstructor e1(100);
//	//ExplicitConstructor e2 = 200; // explicit 키워드가 대입 연산자에서 생성자로 묵시적 형변환을 막기 때문에...
//
//	cout << "#####################################################################################" << endl;
//
//
//	return 0;
//}