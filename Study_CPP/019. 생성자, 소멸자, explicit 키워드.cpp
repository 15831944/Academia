/*

##############################################
   생성자(Constructor)와 소멸자(Destructor)
##############################################

case 1. 생성자(Constructor)

- 클래스의 이름과 같으며, 반환형이 없는 함수와 같은 형태.
- 매개변수의 차이에 따라 다른 생성자가 된다.(Overloading 개념 추가)

- 클래스 외부에서 객체를 생성하기 위해서, 생성자는 주로 public으로 Access Modifier를 지정해준다.

- 객체 생성 시, 생성자는 반드시 호출된다.(컴파일러가 추가해주는 default constructor가 존재하기 때문에)

- constructor는 객체 멤버들을 초기화 하는데 주로 사용된다.

##############################################################################
- 생성자는 주로 "0" 초기화, init 함수는 의미있는 값을 넣어주는 용도로 쓴다고?!
##############################################################################


#######################
  Default Constructor
#######################

- 매개변수가 없고, 컴파일러에 의해 자동으로 생성되는 constructor를 의미한다.
- 사용자가 임의로 생성자를 구현했다면, 컴파일러가 default 생성자를 만들지 않는다 !!!!

########################################################
- 모든 객체의 생성은 생성자 호출에 의해 완성이 된다 !!!!
########################################################


###############################
case 1. [default] 생성자의 정의
###############################
class Student {

public:
	Student() { // default 생성자
		cout << "디폴트 생성자" << endl;
	}
}

int main(void) {

	Student std1; // 객체 생성 시, 생성자는 반드시 호출된다.
				  // 매개변수로 해당 생성자를 찾지 못할 경우, 컴파일 오류.
	cout << "main 함수" << endl;

}

#########################################
 case 2. 매개변수가 존재하는 생성자의 정의
#########################################
class Student {

public:
	Student(int num) {
		cout << "매개변수 존재하는 생성자"<<endl;
	}
}

int main(void) {

	Student std2(100); // 객체 생성 시, 생성자는 반드시 호출된다.
					   // 매개변수로 해당 생성자를 찾지 못할 경우, 컴파일 오류.
					   // 객체 생성 시 "()"를 통해 인자를 넘겨줄 수 있다.
					   // 물론, overloading 개념을 통해 Default Constructor도 만들 수 있음.

	cout << "main 함수" << endl;
}

##################################################################################################

######################################
   if) 멤버 변수를 초기화 하는 방법
######################################
물론, Operator overloading을 했으니까 가능함 !!!!

Student std2 = 100; // in C, 일반 자료형이 아닌데 대입하니까 혼동을 할 수도...
					// "std2 = 100;"이라는 문장이 "std2(100);" 의 형태로 
					// Implicit 형 변환이 일어나기 때문에?!

Student std3(200); // in C++


###################
  explicit 키워드
###################

- 생성자에 "explicit" 키워드를 사용하면, 대입 연산에 의한 생성자의 Implicit 호출을 막는다.
So, Student std2 = 100; 형태는 불가능.
오로지 Sutdent std2(100); 형태로 하도록 !!!!

ex.
class Student {

public:
	explicit Student(int num) {
		cout << "매개변수 존재하는 생성자"<<endl;
	}
}

##################################################################################################

case 2. 소멸자(Destructor)

- 객체 소멸(delete) 시, 반드시 호출 되는 함수이다. (컴파일러에 의해 default destructor가 생성된다.)
(정적 객체는 프로그램이 종료되거나 delete 연산자로 메모리를 해제할 때...
동적 객체는 delete 연산자로 메모리 해제할 때 !!!!)

- 물론, 클래스 외부에서 접근해서 객체의 소멸을 하도록, 주로 public으로 Access Modifier를 지정해준다.
(주로, 메모리 동적 할당을 받은 멤버의 메모리를 해제할 때 사용한다.)

(메모리 해제하는 함수를 소멸자에 넣어서 사용하는 것이 오히려 좋을 수도?!
- 로직에 따라서 다르겠지만, 도중에 메모리를 해제할 필요가 있을 경우...)

- Destructor는 overloading이 불가능하다 !!!!


ex. [default] 소멸자의 정의

class Student {

	~Student() {

		cout << "디폴트 소멸자" << endl;
	}
}


##################################################################################################

#########################################
   메모리 동적 할당 방식과 Constructor
#########################################

in C++
- new 연산자를 사용하여 class를 메모리 동적 할당할 경우, 생성자가 호출된다.
- delete 연산자를 사용하여 메모리 해제할 경우, 소멸자가 호출된다.

in C
- malloc(), calloc() 함수를 이용한다면, 생성자가 호출 되지 않는다.
- free() 함수를 통해 메모리 해제를 하면, 소멸자가 호출 되지 않는다.


##################################################################################################

##############################
     생성자와 소멸자 정리
##############################

case 1. 객체 생성 과정
- 메모리 할당 - 생성자 호출 - 객체 생성


case 2. 객체 소멸 과정
- 소멸자 호출 - 메모리 반환 - 객체 소멸


##################################################################################################


*/

#include "stdafx.h"

class Student {

private:
	int num;

public: // 주로, 생성자와 소멸자는 public
	Student() { // Default constructor 형태.
				// 아무 생성자도 정의가 되어 있지 않으면, 컴파일러가 자동으로 추가해준다.
		num = 0;
		cout << "Default 생성자: " << this->num << endl;
	}

	Student(int num) { // 매개변수가 있는 Constructor

		this->num = num;
		cout << "매개변수 있는 생성자: " << this->num << endl;
	}

	~Student() { // Destructor는 overloading 안 된다 !!!!

		cout << "Overloading 안 되는 소멸자: " << this->num << endl;
	}

};

class ExplicitConstructor {

public:
	explicit ExplicitConstructor(int num) { // 생성자에 추가한 explicit 키워드는 해당 클래스의 객체에 대한 대입 연산이
											// implicit 형 변환으로 생성자 형태를 가질 수 없게 한다 !!!!

		cout << "explicit 생성자는 대입으로는 호출 안 됩니다." << endl;
	}

};

int main(void) {

	cout << "#####################################################################################" << endl;
	cout << "### Constructor & Destructor" << endl << endl;

	Student std1;
	Student std2 = 100; // 일반 자료형이 아니기 때문에, 정확히 무엇을 의미하는지 파악하기가 어려움.
						// 그래서, 이 과정을 막아야 함.
	Student std3(200);

	// 생성자는 std1 -> std2 -> std3 소스 코드 순서로 호출
	// but, 소멸자는 std3 -> std2 -> std1 객체 생성 순서와 반대로 호출된다 !!!!
	// 스택을 생각하면 이해하기 쉬움.
	cout << endl;

	Student *ptr1 = new Student(); // 프로그램이 종료되어도, 소멸자 호출 안되네?!
	Student *ptr2 = new Student(400);
	cout << endl;

	if (ptr1 != nullptr) { // 메모리 동적 할당 받은 객체는 delete 연산자를 통해 메모리 반납을 해야 소멸자를 호출한다 !!!!

		delete ptr1;
		ptr1 = nullptr;
	}

	if (ptr2 != nullptr) {

		delete ptr2;
		ptr2 = nullptr;
	}

	cout << "#####################################################################################" << endl;
	cout << "### Explicit 키워드와 Constructor" << endl << endl;

	ExplicitConstructor e1(100);
	//ExplicitConstructor e2 = 200; // explicit 키워드가 대입 연산자에서 생성자로 묵시적 형변환을 막기 때문에...

	cout << "#####################################################################################" << endl;


	return 0;
}

