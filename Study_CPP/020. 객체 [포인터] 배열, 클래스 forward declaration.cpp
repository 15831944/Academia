/*
#################
    객체 배열
#################

- 클래스도 사용자 정의 자료형의 일종이므로, 배열 선언이 가능하다.
- 두 가지 경우, 객체를 생성하는 것이므로 생성자 호출이 된다 !!!!

Student stdArr1[3]; // 정적 배열 형태
Student *ptrStdArr = new Student[3]; // 동적 배열 형태


#####################################################################################################

######################
   객체 포인터 배열
######################

Student *ptrArr[3]; // 객체의 주소를 저장할 메모리 공간을 만든 것이다.
					// 객체를 실질적으로 생성하는 것이 아니다.
					// 크기 4 * 3 = 12 bytes


ptrArr[0] = new Student; // 객체 생성 !!!!
ptrArr[1] = new Student;
ptrArr[2] = new Student;


#####################################################################################################

#############################################
   클래스의 전방 선언(Forward Declaration)
#############################################

- 수 많은 클래스를 정의하였을 때, 서로가 #include를 통해 참조해야 한다면,
상호 참조로 인한 꼬임 및 무한 참조 현상이 발생하게 되어 문제가 생긴다 !!!!

- 해당 클래스가 존재하고 있다고만 알려줌.
(해당 클래스에서 소스코드의 아랫부분에 존재하는 클래스를 사용할 때 사용함.)


##############################
   Forward Declaration 장점
##############################
- 전방 선언은 클래스의 존재를 알려주기만 해서, 컴파일 속도 향상을 기대할 수 있다.
물론, 해당 클래스의 변수나 함수를 알 수 없음 !!!!
(포함하는 header 파일이 많을수록 컴파일이 느려진다.)


###################################
   Forward Declaration 주의 사항
###################################

- 사용하려는 클래스가 존재한다는 것을 알려주는 역할을 할 뿐, 크기와 기능까지 알지 못한다.
(#include로 포함 한 것이 아니라서 클래스의 생성자를 알 수가 없기 때문에, 해당 클래스의 객체를 생성할 수 없다.
그래서, 포인터 형식으로 사용해야 한다.
포인터 형은 4bytes의 고정된 크기를 가지기 때문에,
컴파일러가 객체의 포인터가 포함된 해당 클래스의 크기를 쉽게 알 수 있다.)


###############################################################################
- 전방 선언된 해당 클래스의 함수(기능)를 사용하고자 할 때,
반드시 소스 코드에 전방 선언된 클래스의 header 파일을 반드시 포함해주어야 한다.
(물론, 그래야 해당 클래스의 정보를 알기 때문에 !!!!
###############################################################################



ex.

=== A.h ===
class B; // 이것이 Forward Declaration?!

class A
{
private:
	B *ptrB; // 해당 클래스의 객체 생성이 불가능하기 때문에, 포인터를 사용해야 한다. 
			 // 왜냐하면, #include를 한 것이 아니기 때문에 사용하고자 하는 클래스의 정보를 알 수가 없다.
}

=== B.h ===
class B
{
	구현 ...
}

#####################################################################################################

*/

#include "stdafx.h"

class Student
{

};

int main(void)
{
	Student stdArr[3]; // 객체 배열(정적)
	Student *ptrStdArr = new Student[3]; // 객체 배열(동적)

	Student *ptrArr[3]; // 객체 포인터 배열(정적)

	ptrArr[0] = new Student; // 실질적으로 객체를 생성하여 주소 값을 넣어주는 것.
	ptrArr[1] = new Student;
	ptrArr[2] = new Student;
	
	return 0;
}

