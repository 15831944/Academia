/*

###########################################
	  복사 생성자(Copy Constructor)
###########################################

- 매개변수로 "객체의 reference"를 갖는 생성자를 의미한다.
(호출 시, 멤버 변수에 있는 값들이 복사가 이루어진다.)

- 여기서 말하는 값은 메모리 공간이 저장하고 있는 값(실제 값, 주소 값 등)...

- 사용자가 복사 생성자를 정의하지 않으면, 컴파일러가 Default 복사 생성자를 만들어준다.
그렇지만, 얕은 복사를 지원하기 때문에,
클래스의 멤버 변수 중에 포인터가 있다면, 우리가 원하는 깊은 복사를 구현해야 한다 !!!!


생성자가 stack에 할당되면 크기가 어느정도?!


#####################################################################################################

###############################################
   복사 생성자(Copy Constructor)의 호출 시점
###############################################


###################################################
case 1. 객체 선언 시, 생성자에 객체가 전달되는 경우
###################################################

Copy c1;
Copy c2(c1); // 복사 생성자 호출


##########################################
case 2. 함수의 인자로 객체가 전달되는 경우
##########################################

void Func(Copy ref) {}

Copy c1;
Func(c1); // 복사 생성자 호출

해당 함수 call에 의한 stack이 생성되고, ref라는 매개변수에 객체 c1이 전달된다.
So, "case 1"과 같은 경우 !!!!


############################################
case 3. 함수의 반환형이 객체로 되어있는 경우
############################################

Copy Func() {
	Copy cTemp;
	return cTemp; // 복사 생성자 호출
}

Copy c1 = Func(); // 복사 생성자 호출
// but, 생성자가 explicit 키워드가 붙었다면?!


#####################################################################################################

#############################################################
   복사 생성자의 매개변수로 객체의 reference를 가지는 이유
#############################################################

- 복사 생성자의 호출 이유가 객체로 다른 객체를 초기화시키려고 사용하는 것임.

if(매개변수 형이 그냥 객체였다면)
- 멤버 복사를 위한 생성자를 호출하였으나,
생성자의 매개변수에도 복사가 필요한 경우가 되어버림.
So, 계속 그 과정이 반복되므로 논리적으로 맞지가 않음.

if(매개변수 형이 객체의 포인터라면)
- 포인터는 주소 값의 복사가 이루어지기 위해 4bytes의 공간이 필요하다.
또한, 포인터 연산이 가능하기에 잘못된 메모리 접근의 위험성이 있다.

but, reference는 원본과 같은 메모리 공간을 공유하기에 메모리를 절약할 수 있다.


##################################################################################################
그리고, reference 형으로 객체 하나만 받아온 생성자가 아니면 복사 생성자로 인식을 하지 않는다 !!!!!
##################################################################################################

- 포인터를 이용한 것은 그냥 일반적인 생성자인데 매개변수가 포인터 형인 것.


#####################################################################################################


###################################################
	Default 복사 생성자의 문제점 - Shallow Copy
###################################################

- 디폴트 복사 생성자를 통해 두 객체의 멤버 변수간 단순 복사가 이루어진다.
(이 값이 실제 의미가 있는 값이든, 주소이든지 그냥 단순 복사 !!!!)

그렇기 때문에, 포인터 형을 가지는 멤버 변수는 동일한 메모리 공간을 참조하는 것이 된다.
So, 메모리 해제 시, Runtime Error가 발생할 수 있다.


우리가 원하는 것은 같은 값을 독립적으로 갖는 것 !!!!

So, Deep Copy(깊은 복사) !!!!


######################################################################################################

###############################
	 깊은 복사(Deep Copy)
###############################

- 포인터 형 멤버 변수 때문에 생기는 Shallow Copy의 문제점을 해결하기 위해,
복사 받을 객체의 멤버도 따로 메모리 동적 할당을 수행한다.

- 원본 객체의 멤버와 서로 다른 공간을 참조하도록 만들어줘야 한다.


###################################################################
   복사 생성자 사용 시, 무조건 Deep Copy로 정의해줘야 한다 !!!!
###################################################################


######################################################################################################


*/


#include "stdafx.h"


//int gNum = 42; // 이전 파일에 사용되는 extern 키워드 예제에 해당하는 전역 변수
//void Func(int num, int num2) {
//
//	cout << "num: " << num << ", num2: " << num2 << endl;
//}


class Copy {

private:
	int iNum;
	double dNum;

public:
	Copy() {}
	Copy(int a, double b)
		: iNum(a), dNum(b)
	{

	}

	Copy(Copy &ref) { // 사용자가 복사 생성자를 정의했으므로,
					  // 컴파일러가 Default 복사 생성자를 만들어주지 않음.
					  // 물론, Member Initializer를 이용한 얕은 복사를 구현해도 된다 !!!!
		iNum = ref.iNum;
		dNum = ref.dNum;
	}

public:

	void showMember(void) {

		cout << "iNum: " << iNum << endl;
		cout << "dNum: " << dNum << endl << endl;
	}
};

class Copy1 {

private:
	char *name;
	int age;

public:
	Copy1() {}
	Copy1(char *name, int age) {
		int len = strlen(name) + 1;

		this->name = new char[len + 1];
		strcpy_s(this->name, len + 1, name);

		this->age = age;
	}


	~Copy1() {
		cout << "소멸자 호출: " << name << endl;

		delete[] name; // Default Copy Structor는 Shallow Copy를 지원하므로,
						// 객체의 복사가 이루어지면, 객체 멤버 중 포인터 형을 가진 멤버는
						// 가지고 있는 주소값을 그대로 넘겨주게 된다.
						// 그래서, 소멸자에서 delete 연산으로 메모리 해제한다면,
						// 다른 객체의 포인터도 같은 공간을 가리키고 있기 때문에 문제가 발생.
	}
};


class Copy2 {

private:
	char *name;

public:
	Copy2() {}
	Copy2(char *name) {
		int len = strlen(name) + 1;

		this->name = new char[len + 1];
		strcpy_s(this->name, len + 1, name);
	}
	Copy2(Copy2 &ref) {
		int len = strlen(ref.name) + 1;

		this->name = new char[len + 1];
		strcpy_s(this->name, len + 1, ref.name);
	}

	~Copy2() {
		cout << "소멸자 호출 name: " << name << endl;

		delete[] name; // 객체간 포인터형 멤버가 다른 메모리 주소 공간을 가리키고 있으므로, 
					   // 메모리를 해제해도 서로 상관이 없다 !!!!
	}
};

class A {

public:
	A() {}
	A(A &ref, int a) {
		cout << "A &ref, int" << endl;
	}
};

int main(void) {

	cout << "####################################################################" << endl;
	cout << "### 클래스의 복사 생성자" << endl << endl;

	Copy c1(10, 3.14);
	c1.showMember();

	Copy c2(c1);
	c2.showMember();


	cout << "####################################################################" << endl;
	cout << "### 디폴트 복사 생성자의 문제점 - Shallow Copy" << endl << endl;

	Copy1 c3("Hello", 10);
	//Copy1 c4(c3); // Default 복사 생성자 호출.
				 // 소멸자에 delete 연산이 이루어지면, Runtime 오류 발생 !!!!

	// 객체 생성 순서와 반대로 객체 소멸이 진행되기 때문에,
	// "Copy1 c4"가 먼저 멤버 변수의 메모리 해제를 수행한다.
	// "Copy1 c3"도 멤버 변수 name을 가지고 있으며, "Copy1 c4"와 동일한 메모리 공간을 가지고 있다.
	// 그렇지만, 메모리 해제를 수행한 뒤라서 "Copy1 c3"는 할당 되지 않는 메모리를 참조하게 되므로,
	// 메모리 해제를 할 수 없고, Runtime 오류를 발생시킨다.

	Copy2 c5("World");
	Copy2 c6(c5); // 각각의 멤버 변수가 다른 메모리 공간을 가리키고 있기 때문에, 정상적으로 소멸됨.

	cout << "####################################################################" << endl;

	return 0;
}