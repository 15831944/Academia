/*

2019.04.19.02 금

########################
   클래스 상속의 조건
########################

##############################
case 1. Is - A: 모든 ~은 A 다
##############################

Person is a Student : 모든 사람은 학생이다. (X, 모든 경우를 만족하는 것이 아니기 때문에...)

Stuent is a Person : 모든 학생은 사람이다.

So, class Student : public Person

학생은 사람으로부터 추가적인 특성을 갖는다.
하위 클래스일수록 특수화, 구체화, 세분화가 진행된다.
상위 클래스일수록 일반화, 추상화가 진행된다.


################################
case 2. Has - A: ~은 A를 가진다
################################

Player is a Sword : 모든 플레이어는 검이다.
Sword is a Player : 모든 검은 플레이어다.

둘 다 안되므로... "Has - A 관계"를 생각해야 함.

Player has a Sword : 플레이어는 검을 가진다. (O)


############################################################################################################################

#######################
	 다중 상속 - Has - A 관계의 문제를 해결하기 위한...
#######################


- 여러 클래스를 ","를 구분으로 해서 상속을 받을 수 있다.

but, 클래스들이 동일한 이름의 변수나 함수가 가지고 있다면, 모호성으로 인한 컴파일 오류 !!!!


ex. 영역을 지정해서 호출하면 되기는 하지만...

player.Sword::Swing();
player.Axe::Swing();


##############################
	포함 관계(Composition)
##############################

상속 관계가 아닌, 내부에 해당 클래스의 객체를 가지고 있는 것을 의미한다.
So, "Has - A 관계"는 상속이 아닌 포함관계(Composition)로 구현을 해야...


if) 무기가 여러 개라면 플레이어 입장에서는 어떻게 해야하는가 ? !
- 객체 포인터를 이용한다 !!!!

############################################################################################################################

########################################
	 객체 포인터(Pointer to Object)
########################################

- 객체의 주소를 저장하는 포인터를 의미함.

ex. Player 클래스 타입의 포인터 변수는 Player 객체 or Player 클래스를 직접[간접]적으로 상속받는 객체의 주소를 저장할 수 있다.
(상위 클래스 포인터 변수는 하위 클래스의 객체를 가리킬 수 있다 !!!!)


#######################################################################
 상위 클래스의 포인터 변수로 동일한 함수 이름을 가진 함수를 호출할 때
#######################################################################

- 포인터 변수가 가지고 있는 실제 객체를 대상으로 연산을 수행하려면, 동적 바인딩의 개념이 있어야 함.


그리고, Up casting & Down casting에 대한 고찰이 필요함 !!!!

############################################################################################################################

*/



#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////////////////////
// 다중 상속 예제 //
////////////////////

class Sword {

public:
	void Swing() {
		cout << "Sword::Swing()" << endl;
	}
};
////////////////////////////////////////////////////////////////////////////////////////////////

class Axe {

public:
	void Swing() {
		cout << "Axe::Swing()" << endl;
	}
};
////////////////////////////////////////////////////////////////////////////////////////////////

class Player : public Sword, public Axe {

};
////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////
// 포함(Composition) 관계 //
////////////////////////////

class Player2 {

public:
	Player2() {

		pSword = new Sword;
		pAxe = new Axe;
	}

	~Player2() {
		delete pSword; // 물론 nullptr 검사.
		delete pAxe;
	}

	void SwingSword(void) { pSword->Swing(); } // Has - A 관계에서는 객체를 클래스 내에 포함시켜서 사용한다.
	void SwingAxe(void) { pAxe->Swing(); }

private:
	Sword *pSword;
	Axe *pAxe;
};
////////////////////////////////////////////////////////////////////////////////////////////////





////////////////////////////////////////////////////////////////////////////////////////////////
// 객체 포인터 예제 //
//////////////////////

class Obj3 {

public:
	void Render(void) {
		cout << "Obj3::Render()" << endl;
	}
};
////////////////////////////////////////////////////////////////////////////////////////////////

class Player3 : public Obj3 { // Obj 클래스를 직접 상속 받고 있다.

public:
	void Render(void) {
		cout << "Player3::Render()" << endl;
	}

	void RenderPlayer(void) {
		cout << "Player3::RenderPlayer()" << endl;
	}
};
////////////////////////////////////////////////////////////////////////////////////////////////

class Monster3 : public Obj3 { // Obj 클래스를 직접 상속 받고 있다.

public:
	void Render(void) {
		cout << "Monster3::Render()" << endl;
	}

	void RenderMonster(void) {
		cout << "Monster3::RenderMonster()" << endl;
	}
};
////////////////////////////////////////////////////////////////////////////////////////////////

class SubPlayer3 : public Player3 { // Player 클래스가 Obj 클래스를 상속 받고 있으므로,
public:								// SubPlayer 클래스는 간접적으로 Obj 클래스를 상속 받고 있다.
	void Render(void) {
		cout << "SubPlayer3::Render()" << endl;
	}

	void RenderSubPlayer(void) {
		cout << "SubPlayer3::EnderSubPlayer()" << endl;
	}
};
////////////////////////////////////////////////////////////////////////////////////////////////




int main(void) {


	cout << "####################################################################" << endl;
	cout << "### 다중 상속의 문제점" << endl << endl;

	Player player;
	//player.Swing(); // 다중 상속으로 인한 동일한 이름의 멤버가 존재해서 모호성이 생긴다 !!!!

	player.Sword::Swing(); // 영역을 지정하면 호출할 수는 있는데...
	player.Axe::Swing();

	cout << "####################################################################" << endl;
	cout << "### 객체 포인터(Object Pointer?!).01" << endl << endl;

	Obj3 *pObj = new Obj3; // Obj3 객체의 주소를 가질 수 있음.
	Obj3 *pPlayer = new Player3; // Obj3 객체를 직접적으로 상속 받는 클래스의 주소도 저장할 수 있음.
	Obj3 *pMonster = new Monster3;
	Obj3 *pSubPlayer = new SubPlayer3; // Obj3 객체를 간접적으로 상속 받는 클래스의 주소도 저장할 수 있음 !!!!

	Player3 player2;
	Obj3 *Obj2 = &player2; // 물론, 상위 클래스 포인터 변수에 하위 클래스의 주소를 넘겨줬으니까 가능함.

	cout << "상위 클래스의 포인터 변수로 자신 포함 하위 클래스 객체를 가리킬 때" << endl;
	cout << "Function Overriding을 했을 때, 호출 되는 함수는 ?!" << endl;

	pObj->Render(); // 상위 클래스에 있는 함수는 정상적으로 호출이 가능함.
	pPlayer->Render(); // 실제로 들어있는 것은 Player3 객체지만, 호출 되는 것은 최상위 클래스인 Obj3의 Render() 함수.
	pMonster->Render(); // 즉, 포인터 변수의 자료형이 속해있는 클래스를 기준으로 함수 호출을 한다 !!!!
	pSubPlayer->Render();
	cout << endl;

	cout << "Player3 포인터 변수로 해당 클래스 객체와 하위 클래스 객체를 가리킬 때..." << endl;
	Player3 *pPlayer2 = new Player3;
	Player3 *pSubPlayer2 = new SubPlayer3;

	pPlayer2->Render(); // 포인터 변수의 자료형인 Player3 클래스를 기준으로 함수 호출을 생각한다.
	pSubPlayer2->Render(); // 그런데, 함수 내부에 Obj3에서 온 Render() 함수도 있을텐데, Player3의 Render 함수를 호출했다 !!!!
	cout << endl;


	cout << "####################################################################" << endl;
	cout << "Down Casting과 Up Casting 고찰" << endl << endl;

	cout << "다운 캐스팅을 했는데, 왜 상위 클래스에 없는 함수가 호출 되는 것인가..." << endl;
	Player3 *pPlayer3 = (Player3 *)new Obj3; // 다운 캐스팅.
	pPlayer3->Render(); // 그런데 왜 Player3의 Render()가 호출되는 것이지?
						// 실제로 객체에는 Player3의 Render()가 들어있는 것이 아니고, Obj3의 Render()가 들어있음.

	SubPlayer3 *pSubPlayer3 = (SubPlayer3 *)new Obj3; // 다운 캐스팅.
	pSubPlayer3->Render(); // SubPlayer3의 Render()가 호출 됨.


	// 동적 객체가 아닌 정적 객체를 대상으로 다운 캐스팅은 적용되지 않는다.
	// 그렇지만, Up casting은 정상 작동함. (상위 클래스를 기준으로 함수 호출 하니까...)
	//Obj3 obj3;
	//SubPlayer3 subPlayer = (SubPlayer3)obj3; // 컴파일 오류 !!!!

	cout << "####################################################################" << endl;
	cout << "### 객체 포인터(Object Pointer?!).02" << endl << endl;

	Obj3 *pObj4 = new Obj3;
	Obj3 *pPlayer4 = new Player3; // 상위 클래스 포인터 변수로 하위 클래스 객체들 가리키고 있음.
	Obj3 *pMonster4 = new Monster3;
	Obj3 *pSubPlayer4 = new SubPlayer3;

	//해당 객체 포인터의 클래스 타입을 기준으로,
	//해당 타입의 함수와 부모의 함수 호출, 멤버 접근은 허용한다는 것을 확인할 수 있다.
	// 단, 자식의 함수 호출이나 멤버의 접근은 허용되지 않음을 볼 수 있다.


	// 해당 자료형을 기준으로 함수 및 멤버의 접근이 가능하다.


	//pPlayer4->RenderPlayer(); // 컴파일 오류. Obj 클래스 입장에서는 클래스 내부에 해당 함수가 있지 않음.
	//pMonster4->RenderMonster(); // 컴파일 오류.
	//pSubPlayer4->RenderSubPlayer(); // 컴파일 오류.

}