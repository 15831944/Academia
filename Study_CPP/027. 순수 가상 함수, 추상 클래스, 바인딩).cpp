/*


###############################################
     순수 가상 함수(Pure Virtual Function)
###############################################

- 하위 클래스에서 상위 클래스의 가상 함수를 반드시 Overriding을 하여,
해당 함수를 구현(선언부와 정의부를 정의)하도록 강요하는 문법.



#####################################
     순수 가상 함수가 필요한 이유
#####################################

- 일반적인 가상 함수는 하위 클래스가 상위 클래스의 멤버 함수를 Overriding 하여,
상위 클래스의 포인터 변수를 통한 호출 시, 하위 클래스의 멤버 함수를 사용할 수 있도록 하는 함수입니다.

- 만약 상위 클래스의 멤버 함수 기능을 그대로 사용하고 싶으면, 하위 클래스에서 Overriding 할 필요가 없습니다.


- But, 순수 가상 함수는 반드시 하위 클래스가 상위 클래스의 순수 가상 함수를 Overriding 하여,
해당 함수를 구현하고 사용할 수 있도록 강제하는 문법

-> 실제로 구현을 하지 않고 넘어가는 실수를 방지하기 위해서 !!!!


##########################################################################################################################

###################################
    추상 클래스(Abstract Class)
###################################

- 추상 클래스는 순수 가상 함수를 포함하고 있는 클래스를 말합니다.


- 추상 클래스의 객체는 생성할 수 없습니다.
단, 객체 포인터 변수의 타입으로는 사용이 가능합니다.
(오로지, 객체 생성만 불가능 !!!!)


- 하위 클래스에서 해당 순수 가상 함수를 Overriding을 하여 구현하지 않으면,
하위 클래스도 순수 가상 함수를 상속 받기 때문에, 추상 클래스가 됩니다.
(그래서 하위 클래스도 객체를 생성할 수 없게 됩니다.)


##########################################################################################################################

###################################################################
   정적 바인딩(Static Binding) vs. 동적 바인딩(Dynamic Binding)
###################################################################

- 바인딩(Binding)이란, 프로그램 구성 요소의 성격을 결정해주는 것을 의미합니다.

- 프로그램이 함수를 실행하기 위해서는 함수를 호출한 위치와 실제로 위치한 메모리 주소가 연결되어 있어야 합니다.
그리고 이 둘을 연결시켜 주는 것 또한 바인딩의 개념입니다.


- 바인딩 시점이 Compile 시점에서 이루어지면, "정적 바인딩", Static Binding.
  바인딩 시점이 Runtime 시점에서 이루어지면, "동적 바인딩", Dynamic Binding.


- Stack Frame은 이미 컴파일 시 또는 Runtime 시, 결정된 함수의 호출 위치와 실제로 위치한 메모리 주소를 받아서 쓰는 것 ?!?!



###################################
case 1. 정적 바인딩(Static Binding)
###################################

- 컴파일 시점에 바인딩이 되는 것을 말하며, 바인딩된 값과 속성들은 변하지 않고 유지됩니다.

- 컴파일 시, 함수의 호출 위치와 실제로 함수가 위치한 메모리 주소가 연결됩니다.

- 컴파일 시, 많은 정보가 결정되므로 컴파일 시간은 오래걸릴지라도, 프로그램 실행 시 효율적이며 빠릅니다.


####################################
case 2. 동적 바인딩(Dynamic Binding)
####################################

- 컴파일 시점에는 바인딩을 보류하였다가, Runtime 시점에 바인딩이 결정되는 것을 의미합니다.

- 런타임 시점에 바인딩 된 속성들이 변할 수 있습니다.
(ex. 메모리 동적 할당으로 구현하는 동적 배열의 크기 변동)

- 프로그램의 유연성이 생기는 반면, 프로그램 실행 속도면에서는 정적 바인딩보다 속도가 느립니다.


##########################################################################################################################

###########################################
     함수 호출(Function Call)과 바인딩
###########################################


case 1. 가상 함수가 아닐 경우(일반 함수), 정적 바인딩 

- 컴파일러는 객체 포인터 변수의 자료형을 기준으로 멤버 함수 호출을 판단합니다.
즉, 이미 컴파일 시점에서 함수의 호출 번지가 결정되는 것을 의미합니다.



case 2. 가상 함수를 사용한 경우, 동적 바인딩

- 가상 함수는 가상 함수 포인터와 가상 함수 테이블을 통해 실제 대상 객체의 가상 함수가 호출됩니다.
그렇기 때문에 클래스 내부에 가상 함수가 있다면, 컴파일러는 객체 포인터 변수의 자료형을 기준으로 판단하지 않고 보류합니다.

- 런타임 시, 객체 포인터 변수가 가상 함수 테이블에 있는 실제 대상 객체의 멤버 가상 함수를 호출할 수 있도록 결정이된다.


##########################################################################################################################


*/

#include <iostream>


using std::cout;
using std::endl;
using std::cin;

/////////////////////////////////////////////////////////////////////////////
// 하위 클래스에서 일반적인 가상 함수를 가진 상위 클래스를 상속 받았을 때...
class Obj
{
public:
	virtual void Render(void)
	{
		cout << "Obj::Render()" << endl;
	}
};

class Player : public Obj
{
	// 따로 Overriding을 하지 않았으므로, 상위 클래스인 Obj 클래스의 Render() 함수를 상속 받아온다.
};
/////////////////////////////////////////////////////////////////////////////
// 하위 클래스에서 순수 가상 함수를 가진 상위 클래스를 상속 받았을 때...
class Obj2
{
public:
	virtual void Render(void) = 0; // "C++"의 Pure Virtual Function의 형태.
								   // 해당 클래스는 추상 클래스가 되며, 해당 클래스를 상속 받는 하위 클래스가 함수를 구현하도록 강제성을 부여합니다.
								   // So, 하위 클래스에서 구현을 하거나,
								   // 아니면 하위 클래스도 순수 가상 함수를 만들어서 Abstract Class가 되거나..
};

class Player2 : public Obj2
{
	virtual void Render(void) // 구현을 하지 않으면, 추상 클래스라서 객체를 못 만든다 !!!!
	{
		cout << "Player2::Render()" << endl;
	}
};
/////////////////////////////////////////////////////////////////////////////


int main(void)
{
	cout << "####################################################################" << endl;
	cout << "### " << endl << endl;

	// #####################################################################
	// 상위 클래스의 멤버 함수가 순수 가상 함수가 아닌 일반 가상 함수일 경우
	// #####################################################################
	// 하위 클래스에서 해당 함수를 Overriding 하면, 실제 대상 객체의 가상 함수가 호출 되는 것이고,
	// 그렇지 않다면, 상위 클래스의 가상 함수를 상속 받았기 때문에 해당 함수를 호출한다.
	//
	// 아무튼, 객체 생성 및 호출은 정상적으로 가능하다.
	Obj *pObj = new Player;
	pObj->Render();
	cout << endl;

	// #############################################################
	// case 2. 상위 클래스의 멤버 함수 중 순수 가상 함수가 있을 경우
	// #############################################################
	// 하위 클래스에서 해당 함수를 구현하지 않으면, 객체를 만들 수가 없다 !!!!
	// 그래서 하위 클래스에서 구현을 해줬기 때문에, 아래와 같이 객체 생성이 가능함.
	Obj2 *pObj2 = new Player2;
	pObj2->Render();

	cout << "####################################################################" << endl;


	return 0;
}