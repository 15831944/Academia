/*

2019.04.24.02 수

####################################
	inline Function(인라인 함수)
####################################

- 매크로 함수의 장점을 취하고, 단점을 보완한 함수.

매크로의 장점 : 해당 코드를 단순 치환하기 때문에, 속도가 빠름.
매크로의 단점 : 복잡한 함수 구현이 어려움, 연산자 우선 순위를 고려해야 함, 디버깅 어려울 수도 있음(컴파일러에 따라서...).


그러나, inline 함수는 매크로의 장점인 자료형에 상관 없는 것은 좀 아쉽지만, 템플릿을 사용하면 해결됩니다.

###################################################################

- inline 함수는 컴파일 시점에 함수 호출 위치에 바로 함수 코드 내용이 그대로 삽입됩니다.
그리고, inline 함수는 헤더 파일에 선언 뿐만 아니라 정의되어 있어야 함 !!!!

- 컴파일러에 의해  함수의 인라인화 유무를 결정됩니다.
그래서, 함수에 inline 키워드 선언을 해도 인라인 처리가 안 될 수도 있습니다 !!!!
but, 함수에 inline 키워드 선언이 없어도 인라인 처리가 될 수 있습니다 !!!!

- 그래도 가독성을 위해 inline 키워드를 써줄 것!!!!



############################################
   inline 함수가 일반 함수로 바뀌는 경우
############################################

case 1. 인라인 함수를 함수 포인터로 활용할 때,
		(Compile 시점에 주소를 알아야하기 때문에, 단순 치환 안 됨.)

case 2. 인라인 함수를 재귀 형태로 호출할 때
		(컴파일 시점에 몇 번 호출해야 하는지 몰라서...)

case 3. 컴파일러에 따라 inline화 되는 규칙이 다름.



물론, Runtime 시점에 호출 주소가 결정되는 가상 함수는 Compile 시점에 inline화로 단순 치환이 되지 않음.


##########################################
  언제 inline 함수를 사용해야 하는가?!
##########################################

- 짧은 문장의 함수...(1줄짜리 !!!)

특히, get(), set() 함수 같은 것들 !!!!


#######################################################################################################################

과제.

다형성을 이용하는 Render(), Init() 순수 가상 함수로 만들고,
나머지 virtual 키워드 빼기.

그리고 자식 클래스에서 호출하려면 casting을 해서 쓰도록 !!!!


*/


#include <iostream>

using std::cout;
using std::endl;
using std::cin;

inline int InlineSquare(int x)
{
	return x * x;
}

int main(void)
{
	cout << "######################################################################" << endl;
	cout << "### 인라인(inline) 함수" << endl << endl;

	cout << "Inline Square: " << InlineSquare(2 + 2) << endl;
	// 컴파일러가 해당 인라인 함수의 코드를 복사 함.
	// 인자의 연산자 우선 순위를 생각할 필요도 없음.
	
	cout << "######################################################################" << endl;


	return 0;
}