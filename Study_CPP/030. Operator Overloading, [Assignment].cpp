/*

###########################################
   연산자 오버로딩(Operator Overloading)
###########################################

- 클래스 대상으로 수행할 때, 기존에 존재하는 연산자의 의미를 바꿀 수 있다는 것을 의미함.
- 연산자 오버로딩은 좌측 객체 기준으로 수행합니다.
(왜냐하면, 연산자 자체도 함수를 의미하기 때문에 !!!!)


- 클래스 내부에 operator() 함수를 구현하였기 때문에, 멤버 함수 호출 방식으로도 사용이 가능하다 !!!

#######################################################################################################

######################################################
   덧셈 연산자 in 산술 연산자(Arithmetic operator)
######################################################

########################
case 1. 객체 + 객체 연산
########################

Point 클래스 대상으로 멤버 함수로서, "Operator Overloading"

Point operator+ (Point &ref);

- 이때, 반환형이 "Reference"가 되지 않도록 한다.

(왜냐하면 반환하는 대상이 매개변수로 받아오는 객체가 아니라,
함수 내부에 선언된 임시 객체를 반환하기 때문에,
함수 종료가 되면 영역을 벗어나므로 임시 객체는 사라지게 된다.
So, 잘못된 메모리 접근 가능성이 생긴다 !!!!)



##########################
case 2. 일반 자료형 + 객체
##########################

Point point23 = 400 + point1; // 컴파일 오류, 좌측 객체 기준으로 생각하기 때문에...
Point point23 = operator+ (400, point21); // 둘 다 같은 형식.


############################################
그래서, 우회하는 방법을 선택해야 합니다 !!!!
############################################

- "Operator Overloading"을 클래스 외부의 "전역 함수"로 정의하면 됩니다.
(물론, 매개변수 선언도 해당 연산 순서로...)

- 단, 전역으로 정의해줄 떄에는 인자 중 하나는 무조건 객체 타입이어야 합니다.
그 중에서도 객체 포인터가 아닌 "순수 객체 타입"과 "Reference"가 와야한다.



###################################################################
So, 클래스 멤버 함수로만 "Operator Overloading"을 구현해야하는 경우
###################################################################

 - 연산의 교환 법칙이 허용되지 않는 경우를 의미합니다.

 case 1. 대입 연산자 - "="

 case 2. 함수 호출 연산자 - "()"

 case 3. 배열 인덱스 연산자 - "[]"

 case 4. 멤버 접근 포인터 연산자 - "->"

#######################################################################################################

##############################################################
   대입 연산자 오버로딩 (Assignment Operator Overlaoding)
##############################################################


#######################
  디폴트 대입 연산자
#######################
- 객체 생성 시, 사용자가 정의하지 않았다면 컴파일러가 자동 생성해주는 함수들 중 하나 !!!!
(생성자, 소멸자, 복사 생성자, 대입 연산자)

- 컴파일러가 생성 해준 "Default Assignment Operator"는
멤버들 간 단순 대입을 해주기 때문에 "얕은 복사"를 진행합니다.
(메모리 동적 할당한 멤버를 갖는 경우, 대입 연산자도 깊은 복사 방식으로 "Operator Overloading")



대입 연산자의 Operator Overloading - Default 형태, 멤버 간 단순 대입.
Point& operator= (Point &ref)
{
	xPos = ref.xPos; // 멤버를 복사함.
	yPos = ref.yPos;

	return *this; // 반환값을 지정하는 이유는 point1 = point2 = point3;
				  // 연속적인 대입 연산을 수행하기 위해서 !!!!
}


Visual Studio(IDE)의 연산자 색깔이 다르다니 !!!!
- 검정색은 일반적인 의미의 연산자.
- 색깔 있는 것은 "Operator Overloading".

########################################################################################
- 객체 생성과 동시에 대입은 복사 생성자의 호출입니다 !!!!
(이미 만들어진 객체를 대상으로 대입 연산을 해줄 떄 호출 되는 것이 대입 연산자입니다 !!!!
########################################################################################

#######################################################################################################

*/

#include <iostream>

using std::cout;
using std::endl;
using std::cin;
using std::ostream;

class Point
{
public:
	explicit Point() {}
	explicit Point(int x, int y)
		: xPos(x), yPos(y)
	{
		//cout << "explicit Point(int x, int y)" << endl;
	}

	// 복사 생성자 - Default 형태 !!!!
	Point(Point &ref)
		: xPos(ref.xPos), yPos(ref.yPos)
	{
		cout << "Default Copy Constructor" << endl;
	}

	~Point() {}


public:
	Point operator+ (Point &ref) // 해당 클래스 객체가 더해질 때 !!!!
	{							 // 반환형이 "Reference"가 되지 않도록 조심할 것.
								 // 함수 내부의 지역 변수를 반환하는 것이기 때문에, 예상치 못한 접근이 가능함 !!!!
		cout << "Point operator+ (Point &ref)" << endl;
		return Point(xPos + ref.xPos, yPos + ref.yPos); // 임시 객체를 반환하지만,
														// 그대로 바로 넣어주는 것으로 컴파일러가 최적화를 진행한다 !!!!
	}

	Point operator+ (int n) // 해당 클래스 객체 대상으로 int 자료형이 덧셈 될 떄 !!!!
	{
		cout << "Point operator+ (int n)" << endl;
		return Point(xPos + n, yPos + n); // 임시 객체를 반환하지만,
										  // 그대로 바로 넣어주는 것으로 컴파일러가 최적화를 진행한다 !!!!
	}

	// 대입 연산자의 Operator Overloading - Default 형태 !!!!
	Point& operator= (Point &ref)
	{
		cout << "Default Assignment Operator" << endl;
		xPos = ref.xPos; // 멤버를 복사함.
		yPos = ref.yPos;

		return *this; // 반환값을 지정하는 이유는 point1 = point2 = point3;
					  // 이러한 문장을 수행하기 위해서 !!!!
	}

	friend ostream& operator<< (ostream &out, Point &ref) // "<< Operator Overloading"
	{													  // ostream 클래스 내부에 private 멤버...
		out << '(' << ref.xPos << ", " << ref.yPos << ')';
		return out;
	}

private:
	int xPos;
	int yPos;
};

// ###################################################
// 좌측에 오는 피 연산자가 해당 클래스가 아닌 경우...
// ex. 일반 자료형 + 해당 클래스 객체
// 
// 우회하는 방법 - 클래스 외부의 전역 함수를 이용 !!!!
// ###################################################

Point operator+ (int n, Point &ref) // 임시 객체를 "Reference"로 반환하지 맙시다 !!!!
{
	cout << "Point operator+ (int n, Point &ref)" << endl;
	return Point(ref + n); // Point& operator+ (int n)을 통해 객체가 만들어지고...
						   // 그것을 통해서 복사 생성자가 호출 된다.
						   // 왜냐하면, 클래스 외부라서 get(), set() 함수가 아니고서는 멤버에 접근 불가능이니까...
						   // 클래스 멤버로 "Operator Overloading"한 것을 그대로 썼음...
}


int main(void)
{
	cout << "################################################################################" << endl;
	cout << "### The concepts of The Operator Overloading" << endl << endl;

	// 각 X, Y 좌표끼리 덧셈을 수행하게 하고 싶음.
	Point point11(100, 200);
	Point point12(300, 400);

	cout << "point11: " << point11 << endl;
	cout << "point12: " << point12 << endl << endl;


	Point point13 = point11 + point12; // 둘 다 같은 형식.
	Point point14 = point11.operator+(point12); // 멤버 함수 호출 방식으로 한 것임.

	// 클래스 멤버로 정의된 Point& operator+ (Point &ref) 함수는 좌측 객체 point11을 기준으로 수행됩니다. 
	// 내부에서 인자로 들어온 point12 객체의 멤버를 이용하여 각 좌표끼리 덧셈을 진행합니다.
	// 그 결과를 반환하여 point3에 복사 생성을 하고 있는 형태

	cout << "point13: " << point13 << endl;
	cout << "point14: " << point14 << endl << endl;


	cout << "#################################################" << endl << endl;

	Point point21(100, 200);
	cout << endl;

	cout << "point22" << endl;
	Point point22 = point21 + 400; // 클래스를 선언과 동시에 객체로 초기화 하므로, 복사 생성자 호출 !!!!
	cout << endl;

	cout << "point23" << endl;
	Point point23 = 400 + point21; // (연산자 오버로딩 안했을 경우) 컴파일 오류, 좌측 객체 기준으로 생각하기 때문에...
	cout << endl;				   //
								   // 그래서, 우회하는 방법을 선택해야 합니다 !!!!
								   // "Operator Overloading"을 전역 함수로 만들어야합니다. (매개변수도 해당 연산 순서로...)
								   // 단, 전역으로 정의해줄 떄에는 인자 중 하나는 무조건 객체 타입이어야 한다.
								   // 객체 타입에는 객체 포인터가 아닌 순수 객체타입과 Reference가 와야한다.

	cout << "point24" << endl;				  // #######################################################################################
	Point point24 = operator+ (400, point21); // 둘 다 같은 형식.
	cout << endl;							  // 함수 구현에서 "Point operator+ (int n);"을 사용함.
											  // 내부에서 임시 객체를 생성하고 지역 변수에 저장하는 것이 아니고 바로 return 하기 때문에,
											  // point24 객체가 생성과 동시에 초기화 될때 호출되는 복사 생성자만 호출 된다 !!!!
											  // 컴파일러가 최적화를 해주었다 !!!!
											  // #######################################################################################

	cout << "point22: " << point22 << endl;
	cout << "point23: " << point23 << endl;
	cout << "point24: " << point24 << endl << endl;

	// ###########################################################
	// 멤버 정의로 인한 문제이기 때문에, 교환 법칙에 해당하는 연산
	// 전역으로 정의해줘야 해결할 수 있다.
	// ###########################################################
	// 클래스 멤버 함수로만 "Operator Overloading"해야 하는 경우
	// - 연산의 교환 법칙이 허용되지 않는 경우를 의미함.
	//
	// case 1. 대입 연산자 - "="
	// case 2. 함수 호출 연산자 - "()"
	// case 3. 배열 인덱스 연산자 - "[]"
	// case 4. 멤버 접근 포인터 연산자 - "->"
	// ###########################################################


	cout << "################################################################################" << endl;
	cout << "### Assignment Operator Overloading " << endl << endl;

	Point point31(100, 200);
	Point point32(300, 400);

	Point point33 = point31 + point32; // 객체 생성과 동시에 대입 연산은 복사 생성자 호출

	Point point34;
	point34 = point31 + point32; // 객체 생성 이후의 대입 연산은 디폴트 대입 연산자 호출
								 // 멤버 간 값의 복사로 "얕은 복사"
								 // 그래서, 메모리 동적 할당하는 멤버가 있다면 "깊은 복사"를 하는 로직으로 구현해야 함.

	cout << "################################################################################" << endl;

	Point point41(100, 200);
	Point point42(10, 20);
	Point point43(1, 2);
	cout << endl;

	point41 = point42 = point43; // 애초에, "=" 연산자가 오른쪽부터 수행되므로 원하는 결과가 나옴 !!!!

	cout << "point41: " << point41 << endl;
	cout << "point42: " << point42 << endl;
	cout << "point43: " << point43 << endl;

	return 0;
}