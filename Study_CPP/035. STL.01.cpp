/*


######################################
   STL - Standard Template Library
######################################

- 클래스 템플릿의 집합인 표준 템플릿 라이브러리 입니다.
(C++ 언어 차원에서 지원하는 것이고,
프로그래밍에 필요한 자료구조 및 알고리즘을 클래스 템플릿화하여 제공합니다.)

- 템플릿을 기반으로 하기 때문에, 모든 자료형을 호환하므로,
"일반화 - Generic"이라고도 합니다.


###############################
    "STL"의 구성 요소 4가지
###############################

- Container(컨테이너
- Algorithm(알고리즘)
- Function Object(Functor)(함수 객체)
- Iterator(반복자)

#######################################################################################################

###########################
   Container(컨테이너)
###########################

- 데이터를 저장하는 객체, 자료구조를 구현한 객체를 말합니다.

- 연결 리스트를 기반으로 하는 "list"
동적 배열을 기반으로 하는 "vector"
트리 구조를 기반으로하는 "map"

이 외에 multimap, set, multiset, queue, deque, stack 등 여러 종류의 "Container"가 있습니다.


#######################################################################################################

##############################
  "Container"의 구분 기준
##############################

- "Container"는 원소의 배치 방법과 메모리에 저장되는 형태에 따른 구분을 할 수 있습니다.


######################
case 1. 원소 배치 방식
######################

case 1.1. 표준 시퀀스(sequence) 컨테이너
- 선형 구조로 이루어져있습니다.
- list, vector, deque 등이 해당됩니다.

case 1.2. 표준 연관(associate) 컨테이너
- 비선형 구조로 이루어져있습니다.
- map, multimap, set, multiset 등이 해당됩니다.


########################
case 2. 메모리 저장 방식
########################

case 1.1. 배열(연속, 인접 메모리 - contiguous) 기반 컨테이너
- 연속적인 메모리에 저장되는 방식입니다.
- vector, dueque

case 1.2. 노드(node) 기반 컨테이너
- list, map, multimap, set, multiset 등이 해당됩니다.


#######################################################################################################

########################################
  Container Adapter(컨테이너 어댑터)
########################################

- 쉽게, 튜닝이라고 생각할 수 있습니다.
- 기존 컨테이너의 기능 중 일부만 사용하므로,
기능 제한이나 기능이 변형되어 있는 컨테이너를 말합니다.

#######################################################################################################

###############################
     Algorithm(알고리즘)
###############################

- 컨테이너 내부에서 정렬, 삭제, 탐색 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿을 말합니다.

- 대부분의 알고리즘 함수들은 특정 컨테이너의 멤버가 아닌 전역으로 작성이 되어 있습니다 !!!!
(캡슐화를 적극적으로 사용하지 않았습니다.
일반화(Generic) 프로그래밍에서 다수의 컨테이너에 대해 적용할 수 있도록 작성했기 때문에...)

- 자주 사용하는 알고리즘 함수들은 대부분 <algorithm> header 파일에 존재합니다 !!!!

#######################################################################################################

##########################
     Iterator(반복자)
##########################

- 포인터와 비슷한 개념입니다.
(컨테이너 원소에 접근하여 다음 원소를 가리킬 수 있습니다.)

- 컨테이너마다 데이터 저장 방식 및 내부 구조가 다르기 때문에,
순회 방법을 일반화시키기 위해서 사용됩니다.

- 컨테이너마다 반복자 객체를 템플릿화시켜서 만들어 놓았습니다.
(연산자 오버로딩으로 "위치를 증감", "반복자 간 대입, 비교" 등의 연산이 가능합니다.)


#######################################################################################################

#################################
  시간 복잡도 표기법 - (Big-O)
#################################

- 그래프 그림 확인할 것.

case 1. 상수 시간
- 원소 개수에 상관없이 처리 시간이 동일하며, 일정합니다.

case 2. 로그 시간
- 원소 개수의 비율만큼 초반에 처리 시간이 급속도로 증가했다가 일정해집니다.

case 3. 선형 시간
- 원소 개수가 증가하면 처리 시간도 비례하여 증가합니다.

case 4. 지수 시간
- 원소의 개수가 적으면 처리 속도가 빠르지만,
일정 개수 이상이면 처리 시간이 급속도로 증가합니다.

#######################################################################################################

*/


