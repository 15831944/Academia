/*

############################
     "Container"의 특징
############################

##################################################
case 1. 표준 sequence 컨테이너의 "vector" 컨테이너
##################################################

- 동적 배열 기반, contiguous 컨테이너
(인덱스를 통함 Random Access가 가능하여, 상수 시간 복잡도로 탐색이 용이합니다.)

- "front"와 "back"으로 구성되어 있고,
데이터의 추가, 삭제 연산은 "back"의 위치에서 가능합니다.

- vector의 중간 위치에 대한 데이터 추가 및 삭제 연산은
추가적인 공간을 확보하거나 삭제 공간의 활용을 위해,
해당 인덱스 이후의 원소 개수만큼 포인터 이동이 발생합니다.
(선형 시간 복잡도로 연산의 속도가 느리다는 것을 의미 함!!!)

but, 맨 끝(back)에서의 데이터 추가 및 삭제 연산은 속도가 빠릅니다.
(상수 시간 복잡도)

- vector 컨테이너는 동적 배열로 구현되어 있으므로,
배열의 크기를 넘어가는 삽입이 발생할 시,
동적 배열의 재할당 및 복사가 발생합니다.
(선형 시간 복잡도로 연산의 속도가 느립니다.)

물론, 인덱스를 이용할 때 "out of range Runtime Error"가 발생하지 않도록 조심할 것 !!!!

###################################################################
- 원소를 삭제하여도 원소가 존재했던 메모리 공간은 남아있습니다 !!!!
(애초에 공간을 잡아놓은 것이 있기 때문에....)
###################################################################

##################################################################################################################

################################################
case 2. 표준 sequence 컨테이너의 "list" 컨테이너
################################################

- (Double Linked List) node 기반.

- "front"와 "back"으로 구성되어 있고...
데이터의 추가, 삭제 연산은 "front", "back" 둘 다 가능합니다.

- "list"를 구성하는 노드들은 비연속적인 메모리 공간에 저장되어 있지만,
포인터를 통해 각 노드를 연결하고 있기 때문에,
겉보기에 연속된 공간에 나열한 것처럼 보입니다.
("list" 컨테이너는 실제로 연속된 메모리에 저장되는 것이 아니므로,
각 노드에 대한 Random Access가 불가능합니다 !!!!)


So, 임의 접근이 불가능하므로 탐색하고자 하는 데이터가 나올 때까지,
노드가 저장된 순서대로 순회를 해야합니다.
(선형 시간 복잡도로 속도가 느립니다.)


but, "list" 컨테이너의 중간 위치에 데이터 추가 및 삭제 시에는 단순 포인터 연결 및 해체 과정만 하면 되므로...
연속적인 메모리 공간을 사용하는 배열과 달리 데이터를 밀고 당길 필요가 없습니다.

또한, 배열처럼 한정된 메모리 공간을 사용하는 것이 아니기 때문에,
Runtime 동안에도 계속해서 노드를 추가할 수 있어서 데이터 저장에 유리합니다.
(데이터의 복사가 필요 없음 !!!!)



ex. 탐색이 많은지, 중간 위치에 삽입, 삭제 연산이 많은지...
(FPS 게임의 총알의 경우 list?!)


##################################################################################################################

#################################################
case 3. 표준 sequence 컨테이너의 "deque" 컨테이너
#################################################

- 동적 배열 기반, contiguous 컨테이너
(인덱스를 통함 Random Access가 가능하여, 상수 시간 복잡도로 탐색이 용이합니다.)

- "front"와 "back"으로 구성되어 있고...
데이터의 추가, 삭제 연산은 "front", "back" 둘 다 가능합니다.

but, "deque" 컨테이너의 중간 위치에 데이터 추가, 삭제 연산은 "vector" 컨테이너보다 느립니다.
("front" 위치에 삽입하는 경우 최악의 경우로서, 선형 시간 복잡도 !!!!)

##################################################################################################################

######################################################
case 4. 표준 연관(associate) 컨테이너의 "map" 컨테이너
######################################################

#############################
표준 연관 컨테이너(associate)
#############################
- 선형적이지 않은 구조 (비선형적인 자료구조는 트리가 있습니다.)

#############
트리 자료구조
#############
- 연관 컨테이너들은 트리 중에서도 자가 균형 이진 탐색 트리(레드-블랙 트리)로 구현되어 있습니다.

##############
이진 탐색 트리
##############
- 각 노드들이 2개 이하의 자식 노드를 갖는 트리를 의미합니다.
- 이진 탐색 트리는 임의의 노드를 기준으로 좌측은 자신보다 작은 값, 우측은 자신보다 큰 값을 규칙이 있습니다.


- 연관 컨테이너에는 map, multimap, set, multiset 등이 있습니다.


######################
  So, map 컨테이너
######################

- (key-value) 한 쌍의 (Double Linked List) 노드 기반 트리 자료구조

  key : 정렬시킬 저장 위치 결정.
value : 실제 값.

- map 컨테이너의 원소들은 각 key와 value로 한 쌍을 이룹니다.
각 원소들은 삽입 시에 key값에 따라 자동으로 정렬이 됩니다.

- 물론, Iterator를 통한 탐색 또한 가능합니다.
(but, 삽입, 삭제 연산 수행할 때마다 정렬 연산을 수행하기 때문에 매우 속도가 느림...)

#####################################################################
노드 기반 컨테이너(포인터 사용)들 중 유일하게 임의 접근이 가능합니다.
#####################################################################
- Resource 탐색용으로 많이 쓰이며, 중복된 "key"를 허용하지 않는다.
("key"를 통한 Random Access)



ex. 흠..."key"로 플레이어를 담고, "value"로 리스트를 담고 있어서 플레이어의 상태정보를 나타내어준다?!


##################################################################################################################

###########################################################
case 5. 표준 연관(associate) 컨테이너의 "multimap" 컨테이너
###########################################################

- "map" 컨테이너와 매우 비슷합니다.

but, 중복된 "key"를 허용하고 임의 접근은 불가능합니다.


############
set 컨테이너
############
- set 컨테이너는 "key"만 가지고 있고, 중복을 허용하지 않습니다.
대신, 임의 접근이 가능합니다.
- "key"가 저장될 데이터의 위치를 결정할 뿐만 아니라 실제 값을 의미합니다.

#################
multiset 컨테이너
#################
- multiset 컨테이너도 "key"만 가지고 있지만, 중복된 "key"를 허용합니다,
그래서 임의 접근이 불가능합니다.


##################
hashtable 컨테이너
##################
- "key"와 "value"의 쌍으로 데이터를 가지고 있습니다.
- Hashtable 컨테이너는 "key" 입력 시, 내부에서 변환해서 저장
(메모리는 많이 잡아먹지만 속도 측면에서는 매우 빠릅니다.)

##################################################################################################################

*/

#include <iostream>

using std::cout;
using std::endl;
using std::cin;

int main(void)
{
	cout << "############################################################################" << endl;
	cout << "### " << endl << endl;

	return 0;
}